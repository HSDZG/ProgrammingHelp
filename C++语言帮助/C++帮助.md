
# C++帮助文档
[toc]


## 概述
[开头](#c帮助文档)
**起源：**
C++是一种通用的高级编程语言，由Bjarne Stroustrup于20世纪80年代初在C语言的基础上发展而来。Stroustrup的目标是创建一种支持面向对象编程风格的语言，并且保留了C语言的低级控制和高性能特性。

**发展历史：**
C++最早是作为C语言的扩展开发的，其第一版于1983年发布，称为“C with Classes”。之后，在1985年，C++的第一个正式标准发布，称为“C++86”。随后的几年中，C++经历了多个版本的更新和改进，包括“C++98”、“C++03”、“C++11”、“C++14”、“C++17”和“C++20”。

C++在发展过程中逐渐成为一种广泛使用的编程语言。它提供了一系列的特性和功能，包括面向对象编程、模板元编程、泛型编程等，使其能够适应各种开发需求。C++的发展也受到了许多编程范式和技术的影响，如面向对象编程、模板编程、STL（标准模板库）等。

**特点：**
C++具有以下几个主要特点：

1. **面向对象编程：** C++支持面向对象编程（OOP），可以使用类、继承、多态等概念来组织代码和数据。这使得代码更容易理解、重用和维护。

2. **高性能和低级控制：** C++继承了C语言的高性能和低级控制特性，可以直接操作内存和硬件资源，编写高效的代码。

3. **泛型编程：** C++提供了模板，使得编写泛型代码和数据结构变得容易。模板可以根据不同数据类型生成多个对应的代码，提高代码的复用性和通用性。

4. **可移植性：** C++的标准规范（ISO C++标准）定义了语言的规则和特性，使得C++代码可以在不同的平台上进行编译和运行，具有较好的可移植性。

5. **丰富的库支持：** C++拥有广泛的标准库和第三方库，如STL（标准模板库）、Boost库等，提供了大量的数据结构、算法和功能，方便开发者进行快速开发。

C++是一种强大而灵活的编程语言，广泛应用于系统级编程、游戏开发、嵌入式系统、科学计算、图形图像处理等领域。它的语法和特性使得程序员能够编写高效、表达力强的代码，并在多个平台上实现高性能的应用程序。


## 开发环境
[开头](#c帮助文档)

C++的主流开发环境包括集成开发环境（IDE）和文本编辑器等，以下是其中几个常用的开发环境：

**1. Visual Studio**
- **软件大小：** Visual Studio是一个强大的集成开发环境，包括多种语言的开发工具，其中也包括C++。完整的Visual Studio安装包大小为几个GB。
- **特点：** Visual Studio提供了丰富的功能和工具，包括代码编辑、调试、构建、版本控制等。它具有强大的智能代码补全、代码导航和静态代码分析功能，还提供了直观易用的图形用户界面。
- **适用场景：** Visual Studio适用于大型C++项目的开发，如桌面应用程序、游戏开发、系统编程等。其强大而全面的功能使得开发者能够高效地进行代码编写、调试和性能分析。
- **扩展和插件：** Visual Studio拥有众多的扩展和插件，可以根据需要进行安装和配置，如C++ Boost扩展、CMake工具、GitHub扩展等。

**2. CLion**
- **软件大小：** CLion是一款专门为C++开发设计的跨平台集成开发环境，大小约为500MB。
- **特点：** CLion提供了多种功能，包括代码编辑、调试、版本控制等。它具有强大的代码导航、智能代码补全和代码重构功能，还支持CMake、Makefile和其他常用构建系统。
- **适用场景：** CLion适用于各种规模的C++项目开发，包括桌面应用程序、嵌入式系统、游戏引擎等。它的快速编译和调试功能使得开发环境可以提高开发效率。
- **扩展和插件：** CLion可以通过插件来扩展其功能，如Git工具、Markdown支持等。

**3. Xcode**
- **软件大小：** Xcode是苹果公司开发的集成开发环境，用于开发macOS、iOS和其他Apple平台上的应用程序。完整的Xcode安装包大小为几个GB。
- **特点：** Xcode内置了C++支持，提供了代码编辑、调试、界面设计等功能。它还包含了强大的模拟器，用于在macOS和iOS平台上测试和调试应用程序。
- **适用场景：** Xcode主要用于开发基于苹果平台的应用程序，包括原生macOS和iOS应用程序、游戏开发等。它提供了与苹果生态系统紧密集成的功能和工具。
- **扩展和插件：** Xcode可以通过安装扩展来增强其功能，如Clang静态分析工具、Git工具等。

这些主流的C++开发环境提供了丰富的功能和工具，适用于不同规模和类型的C++项目开发。开发者可以根据自己的需求和偏好选择合适的开发环境，并通过安装相应的扩展和插件来满足特定的开发要求。

## 常用头文件
[开头](#c帮助文档)

C++中有许多常用的头文件，下面是其中一些常见的头文件：

1. `<iostream>`：输入输出流，可以用来进行基本的输入输出操作，如标准输入输出（`cin`和`cout`）。
2. `<iomanip>`：输入输出格式控制，用于设置输入输出的格式，如设置精度、字段宽度等。
3. `<vector>`：向量容器，可用于创建和操作动态数组。
4. `<string>`：字符串类，用于创建和操作字符串。
5. `<fstream>`：文件流，用于进行文件的输入输出操作。
6. `<cmath>`：数学函数，包含了一些常用的数学函数，如三角函数、指数函数、对数函数等。
7. `<ctime>`：时间和日期函数，包含了一些处理时间和日期的函数。
8. `<cstring>`：字符串处理函数，提供了一些处理字符串的函数，如复制、连接、比较等。
9. `<algorithm>`：算法函数，提供了一些常用的算法函数，如排序、查找等。
10. `<cstdlib>`：标准库函数，提供了一些通用的函数，如随机数生成、动态内存管理等。

这只是一小部分常用头文件的列表，C++还有许多其他的头文件，可以根据具体需求选择使用。

## 标准
[开头](#c帮助文档)

C++的各个版本都有对应的C++标准，下面是一些常见的C++标准：
| 标准版本 |   发布时间    |      标准名称      |                                                 标准特点                                                  |
| :------: | :-----------: | :----------------: | :-------------------------------------------------------------------------------------------------------: |
|  C++ 98  |    1998年     | ISO/IEC 14882:1998 |           这是最早的C++标准，于1998年发布，它包含了最初的C++语言规范，并进行了一些修正和增强。            |
|  C++ 11  | 2011年8月12日 | ISO/IEC 14882:2011 | 也称为C++0x，于2011年发布。这个标准引入了许多新功能，如自动类型推导、lambda表达式、右值引用和智能指针等。 |
|  C++ 14  | 2014年8月18日 | ISO/IEC 14882:2014 |           于2014年发布，对C++11进行了一些小的改进和修正，如泛型lambda表达式、constexpr函数等。            |
|  C++ 17  | 2017年12月6日 | ISO/IEC 14882:2017 |            于2017年发布，引入了一些有用的功能，如结构化绑定、折叠表达式、if constexpr语句等。             |
|  C++ 20  | 2020年12月7日 | ISO/IEC 14882:2020 |         于2020年发布，包含了一系列的新功能，如概念、协程、范围和概念的基础上引入的范围for循环等。         |

此外，还有一些正在开发中的C++标准，如C++23，将在未来发布并引入新的功能和改进。

需要注意的是，不同编译器对这些标准的支持程度可能有所不同。因此，查看特定编译器的文档以了解其支持的C++标准版本是很重要的。

## 基本语法
[开头](#c帮助文档)

基本语法结构：

C++程序由一个或多个函数组成，其中一个必须是命名为main的函数，作为程序的入口点。
语句由一个或多个表达式组成，以分号作为结束符号。

例：
```C++
int a=1,b=2,c;
c=a+b;
```
大括号{ }用于表示代码块，提供作用域和语句分组。
例：
```C++
int a,b,c;
{
 a=1,b=2,c;
c=a+b;
}
```
下面来看看最简单的C++程序
```C++
#include<iostream>
using namespace std;
//导入相关头文件和命名空间
//命名空间不建议用namespace
//用using最好，比如using std::cout; 
int main() //主函数，程序从这开始执行
{
	cout<<"hello word"<<endl; //显示hell word后换行
	return 0; //返回0代表正常退出
}
```
## main函数
[开头](#c帮助文档)
在C++语言中，`main`函数是程序的入口点，也是程序执行的起始处。所有的C++程序都必须包含一个`main`函数。

`main`函数的定义通常有两种形式：

1. 无参数形式：
```cpp
int main()
{
    // 程序执行的代码逻辑
    return 0;
}
```
上述形式的`main`函数没有任何参数，其中的代码逻辑在程序执行时会被执行。程序执行完毕后，返回值`0`表示程序运行成功。

2. 带参数形式：
```cpp
int main(int argc, char* argv[])
{
    // 程序执行的代码逻辑
    return 0;
}
```
上述形式的`main`函数带有两个参数：`argc`表示命令行参数的数量，`argv`是一个指向字符数组的指针，存储了命令行参数的值，其中`argv[0]`表示程序的名称。

无论是哪种形式的`main`函数，其返回类型必须是`int`类型。返回值`0`通常表示程序执行成功，非`0`的返回值表示程序执行失败或出错。

以下是一个简单的例子：
```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
```
上述代码中的`main`函数没有参数，输出字符串"Hello, World!"，然后返回`0`表示程序执行成功。

需要注意的是，在C++中，`main`函数在程序中只能存在一个，并且必须有且仅有一个`main`函数。

## 注释
[开头](#c帮助文档)
在C++中，注释用于对代码进行解释、补充说明或进行临时禁用某些代码段。C++支持两种类型的注释：单行注释和多行注释。

1. 单行注释：
   - 单行注释以两个斜杠（`//`）开头，可以出现在任何位置，从注释符号开始处到该行的末尾，编译器会忽略该行的内容。
   - 示例：
     ```cpp
     // 这是一个单行注释

     int x = 10; // 这里是一个单行注释
     ```

2. 多行注释：
   - 多行注释以斜杠和星号（`/*`）开头，并以星号和斜杠（`*/`）结束，可以跨越多行，编译器会忽略注释符号之间的所有内容。
   - 示例：
     ```cpp
     /*
       这是一个
       多行注释
     */

     int a = 5;
     /*
      int b = 10;
      这是一个多行注释，编译器会忽略这部分代码
     */
     ```

注释可以提高代码的可读性和可维护性，帮助他人或自己更好地理解代码的目的和实现。它们可以用于解释算法、描述函数功能、标记代码段以进行暂时禁用或调试，或在文档中生成代码示例。建议在编写代码时通过注释来解释代码的目的、功能和实现细节，以方便未来的阅读和维护。


## 标识符
[开头](#c帮助文档)
在C++中，标识符是用来给变量、函数、类、对象和其他用户定义的实体命名的。它们由字母、数字和下划线组成，但必须符合一些规则。以下是关于C++标识符的一些基本知识：

1. 规则：
   - 标识符必须以字母或下划线开头，后面可以是字母、数字或下划线。
   - C++是区分大小写的，因此大写字母和小写字母被视为不同的字符。
   - 标识符不能是C++的关键字，例如`int`、`if`、`while`等。关键字是C++编程语言保留的，用于特定的语法和用途。

2. 命名约定：
   - 选择有意义的标识符名称，以便更好地描述变量、函数或实体的用途和含义。
   - 使用驼峰命名法（Camel Case）或下划线命名法（Snake Case）来命名标识符。驼峰命名法将每个单词的首字母大写，除了第一个单词之外（例如：`myVariableName`），而下划线命名法在单词之间使用下划线分隔（例如：`my_variable_name`）。

以下是一些有效的C++标识符的示例：
```cpp
int myVariable;       // 使用驼峰命名法
int my_variable;      // 使用下划线命名法
void calculateSum();  // 使用驼峰命名法
```

注意，在C++中，标识符的选择是一种良好的编程实践。使用具有描述性和意义的标识符可以提高代码的可读性和可维护性，并帮助他人或自己更好地理解代码的目的和功能。

## 关键字
[开头](#c帮助文档)
C++关键字是编程语言中预定义的具有特殊含义的标识符。它们用于控制程序的结构、定义变量和数据类型、以及执行其他特定的操作。以下是C++的一些关键字：

```cpp
// 控制结构关键字
if      else     switch   case      default
while   do       for      break     continue    return

// 数据类型关键字
int     float    double   char      void
bool    short    long     signed    unsigned

// 存储类关键字
auto    register static   extern    const       mutable    volatile

// 类型修饰关键字
const   constexpr   typedef    decltype   static_cast   dynamic_cast
reinterpret_cast           typeid      sizeof       noexcept

// 类和对象关键字
class   struct   union   enum   virtual   public   private   protected
new     delete   this    operator  friend       inline

// 异常处理关键字
try     catch    throw

// 命名空间关键字
namespace

// 其他关键字
NULL    true    false   asm    alignas   explicit   export
```

这些关键字具有特殊用途，不能作为变量名或其他标识符使用。在编写C++代码时，应避免将关键字用于除其预定的用途之外的任何目的。
## 基本输入输出
[开头](#c帮助文档)
在C++中，可以使用标准库中的输入输出流（iostream）来实现基本的输入和输出操作。常用的输入输出流包括 `cin`、`cout` 和 `cerr`。以下是关于C++基本输入输出的一些知识：

1. 输出内容：
   使用 `cout` 对象，可以向控制台输出各种类型的数据。例如：
   ```cpp
   int age = 20;
   std::cout << "I am " << age << " years old." << std::endl;
   ```
   在上述代码中，使用 `<<` 操作符将字符串和变量 `age` 的值输出到控制台，并使用 `endl` 操作符进行换行。

2. 输入内容：
   使用 `cin` 对象，可以从控制台接收用户输入的数据。例如：
   ```cpp
   int number;
   std::cout << "Enter a number: ";
   std::cin >> number;
   ```
   在上述代码中，使用 `>>` 操作符从控制台读取用户输入的整数，并将其存储在变量 `number` 中。

3. 输出错误信息：
   使用 `cerr` 对象，可以向控制台输出错误信息。例如：
   ```cpp
   std::cerr << "Error: File not found." << std::endl;
   ```
   在上述代码中，将错误消息输出到控制台的标准错误流，并使用 `endl` 操作符进行换行。

值得注意的是，`cout`、`cin` 和 `cerr` 都是用来对标准输入输出进行操作的流对象，它们都位于 `iostream` 头文件中。此外，还可以使用其他格式化输出和输入的功能，如控制输出精度、字段宽度等。

一般情况下，使用 `cout` 进行标准输出，使用 `cin` 进行标准输入，使用 `cerr` 输出错误信息。这些基本输入输出操作可以满足大部分的需求。希望这些知识可以帮助你了解C++中的基本输入输出。

### cin
[开头](#c帮助文档)
在C++中，`cin` 是标准输入流对象，用于从控制台接收用户的输入数据。`cin` 是 C++ 标准库中的一个预定义对象，它位于 `iostream` 头文件中。以下是关于 `cin` 的一些基本知识：

1. 读取输入：
   使用 `cin` 从控制台读取输入非常简单。可以使用 `>>` 操作符将用户的输入值读取到变量中。例如：
   ```cpp
   int number;
   std::cout << "Enter a number: ";
   std::cin >> number;
   ```
   在上述代码中，等待用户在控制台输入一个数字，并将该数字存储在变量 `number` 中。

2. 读取字符串：
   使用 `cin` 读取字符串也非常简单。可以使用 `>>` 操作符读取单词或一行文本，并将其存储在字符串变量中。例如：
   ```cpp
   std::string name;
   std::cout << "Enter your name: ";
   std::cin >> name;
   ```
   在上述代码中，等待用户在控制台输入一个姓名，并将其存储在字符串变量 `name` 中。

3. 读取多个输入值：
   可以使用多个连续的 `>>` 操作符从控制台读取多个输入值。例如：
   ```cpp
   int age;
   std::string city;
   std::cout << "Enter your age and city: ";
   std::cin >> age >> city;
   ```
   在上述代码中，等待用户在控制台依次输入一个年龄和一个城市名称，并将它们存储在相应的变量中。

4. 忽略换行符：
   通常，用户按下回车键后，会在输入的数据中包含换行符。若要忽略此换行符，可以使用 `ignore()` 函数。例如：
   ```cpp
   int age;
   std::cout << "Enter your age: ";
   std::cin >> age;
   std::cin.ignore(); // 忽略换行符
   ```
   在上述代码中，使用 `ignore()` 函数忽略了输入数据中的换行符，以便进行后续的输入操作。

5. 输入错误处理：
   当用户输入的内容与期望的数据类型不匹配时，可以通过检查 `cin` 的状态来处理错误。例如，可以使用 `fail()` 函数检查输入是否失败，并使用 `clear()` 函数清除错误状态。例如：
   ```cpp
   int number;
   std::cout << "Enter a number: ";
   while (!(std::cin >> number)) {
       std::cout << "Invalid input. Please enter a number: ";
       std::cin.clear();
       std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
   }
   ```
   在上述代码中，如果用户输入的内容不是一个数字，就会显示错误消息，并通过 `clear()` 函数清除错误状态。然后使用 `ignore()` 函数忽略错误输入，继续等待用户输入。

`cin` 对象是一个强大的工具，用于从控制台接收用户的输入。希望这些基本知识可以帮助你了解 C++ 中的 `cin` 的使用。

### cout
[开头](#c帮助文档)
在C++中，`cout`是标准输出流对象，用于向控制台输出数据。`cout`是C++标准库中的一个预定义对象，它位于`iostream`头文件中。以下是关于`cout`的一些基本知识：

1. 输出字符串：
   使用`cout`输出字符串非常简单。可以使用"<<"操作符将字符串直接送到`cout`对象中。例如：
   ```cpp
   std::cout << "Hello, World!" << std::endl;
   ```
   在上述代码中，将字符串"Hello, World!"输出到控制台。

2. 输出变量：
   可以使用`cout`输出各种类型的变量。与字符串类似，使用"<<"操作符将变量插入到`cout`对象中。例如：
   ```cpp
   int number = 42;
   std::cout << "The number is: " << number << std::endl;
   ```
   在上述代码中，将变量`number`的值输出到控制台。

3. 控制输出格式：
   可以使用`cout`的一些控制符号来控制输出的格式。例如，可以使用`std::setw()`设置字段宽度，`std::setprecision()`设置浮点数的精度等。例如：
   ```cpp
   double pi = 3.1415926;
   std::cout << std::setprecision(4) << pi << std::endl;
   ```
   在上述代码中，将浮点数`pi`的输出精度设置为4位小数。

4. 标准输出流控制符：
   `cout`对象还具有其他一些标准输出流控制符，用于控制输出的格式，例如：
   - `std::endl`：输出换行符并刷新输出缓冲区。
   - `std::setw(n)`：设置字段宽度为n个字符。
   - `std::setprecision(n)`：设置浮点数的输出精度为n位小数。
   - `std::fixed`：固定浮点数的输出格式，显示小数部分。
   - `std::scientific`：使用科学计数法输出浮点数。

`cout`对象提供了一种简单而强大的方式来输出数据到控制台。希望这些基本知识可以帮助你了解C++中`cout`的使用。

## 文件输入输出
[开头](#c帮助文档)
在C++中，文件输入输出是一种常见的操作，用于读取文件中的数据或将数据写入到文件中。C++提供了`fstream`库，用于文件的输入输出操作。该库包含了三个主要的类：`ofstream`（用于写操作）、`ifstream`（用于读操作）和`fstream`（用于读写操作）。

要进行文件的输入输出，首先需要包含`<fstream>`头文件。然后，可以使用以下步骤进行文件的读取和写入：

文件写入（Output）：
1. 创建一个`ofstream`对象，并打开目标文件。
2. 使用输出流操作符`<<`将数据写入到文件。
3. 关闭文件。

示例：将数据写入文件
```cpp
#include <iostream>
#include <fstream>

int main() {
    std::ofstream outputFile("data.txt"); // 创建ofstream对象并打开文件

    if (outputFile.is_open()) { // 检查文件是否成功打开
        outputFile << "Hello, World!" << std::endl; // 将数据写入文件
        outputFile << 123 << std::endl;

        outputFile.close(); // 关闭文件
    } else {
        std::cout << "无法打开文件" << std::endl;
    }

    return 0;
}
```

文件读取（Input）：
1. 创建一个`ifstream`对象，并打开源文件。
2. 使用输入流操作符`>>`从文件中读取数据。
3. 关闭文件。

示例：从文件读取数据
```cpp
#include <iostream>
#include <fstream>

int main() {
    std::ifstream inputFile("data.txt"); // 创建ifstream对象并打开文件

    if (inputFile.is_open()) { // 检查文件是否成功打开
        std::string line;
        int number;

        // 从文件中读取数据
        std::getline(inputFile, line);
        inputFile >> number;

        std::cout << "Line: " << line << std::endl;
        std::cout << "Number: " << number << std::endl;

        inputFile.close(); // 关闭文件
    } else {
        std::cout << "无法打开文件" << std::endl;
    }

    return 0;
}
```

在使用文件输入输出时，需要注意以下几点：
- 对于输出流对象（`ofstream`或`fstream`），文件会被清空并重新写入数据。如果文件不存在，则会创建一个新文件。
- 对于输入流对象（`ifstream`或`fstream`），必须确保源文件存在且可读。如果文件不存在或无法打开，则操作会失败。
- 在读取文件中的数据时，可以使用输入流操作符`>>`以及`getline()`函数来读取不同类型的数据。

以上是基本的文件输入输出操作，在实际应用中，还可以通过文件流操作来读写更复杂的数据结构，如数组、结构体等。
## 数据类型
### 基本数据类型
[开头](#c帮助文档)
C++提供了一些基本的数据类型，用于存储不同类型的数据。以下是C++的一些基本数据类型：

1. 整数类型：
   - `int`：整数类型，通常为32位。
   - `short`：短整数类型，通常为16位。
   - `long`：长整数类型，通常为32位或64位。
   - `long long`：长长整数类型，通常为64位。
   - `unsigned int`：无符号整数类型，只能表示非负整数。

2. 浮点类型：
   - `float`：单精度浮点类型，通常为32位。
   - `double`：双精度浮点类型，通常为64位。
   - `long double`：扩展精度浮点类型，具体长度依赖于编译器。

3. 字符类型：
   - `char`：字符类型，存储单个字符。
   - `wchar_t`：宽字符类型，用于支持更大范围的字符集。
   - `char16_t`：用于表示Unicode字符的16位字符类型。
   - `char32_t`：用于表示Unicode字符的32位字符类型。

4. 布尔类型：
   - `bool`：布尔类型，存储`true`或`false`。

5. 空类型：
   - `void`：空类型，表示不返回值。

这些基本数据类型可以用于声明变量、函数参数和函数返回值，并用于存储不同类型的数据。此外，C++还提供了一些修饰符，可用于修饰这些基本类型，例如`const`、`signed`、`unsigned`等。

注意，各个类型的长度和范围可能在不同的编译器和平台上有所变化。为了编写可移植的代码，建议使用标准的C++数据类型，并根据项目的需求选择合适的类型来存储数据。
### 变量
[开头](#c帮助文档)

在C++中，变量用于存储和表示值。以下是在C++中声明和使用变量的示例：

```cpp
// 声明变量
int age;                // 声明一个名为age的整数变量
double salary = 2500.50; // 声明并初始化一个名为salary的双精度浮点数变量
char grade = 'A';        // 声明并初始化一个名为grade的字符变量

// 使用变量
age = 25;               // 给变量age赋值为25
int ageInMonths = age * 12;  // 使用变量age进行计算并将结果存储在ageInMonths变量中

// 输出变量的值
std::cout << "年龄：" << age << std::endl;
std::cout << "月份：" << ageInMonths << std::endl;
```

在上述示例中，我们声明了三个变量：age（整数）、salary（双精度浮点数）和grade（字符）。我们还展示了如何使用这些变量，给它们赋值和进行计算。最后，我们使用`std::cout`输出变量的值。

在C++中，变量的类型在声明时必须指定。可以使用各种基本数据类型（如整型、浮点型和字符型），也可以使用自定义的结构和类。

### 数据类型别名
[开头](#c帮助文档)
在C++中，你可以使用`typedef`关键字或C++11引入的`using`关键字来创建数据类型的别名。下面是使用这两种方法创建数据类型别名的示例：

1. 使用`typedef`关键字：

```cpp
typedef int MyInt;                 // 将int类型重命名为MyInt
typedef double Distance;           // 将double类型重命名为Distance
typedef char* StringPtr;           // 将char指针类型重命名为StringPtr
typedef std::vector<int> IntVector; // 将std::vector<int>类型重命名为IntVector

// 使用别名
MyInt age = 25;
Distance length = 2.5;
StringPtr name = "John";
IntVector numbers = {1, 2, 3};
```

在上述示例中，我们使用`typedef`关键字分别创建了`MyInt`、`Distance`、`StringPtr`和`IntVector`的别名，然后可以使用这些别名声明变量。

2. 使用`using`关键字（适用于C++11及更高版本）：

```cpp
using MyInt = int;                 // 将int类型重命名为MyInt
using Distance = double;           // 将double类型重命名为Distance
using StringPtr = char*;           // 将char指针类型重命名为StringPtr
using IntVector = std::vector<int>; // 将std::vector<int>类型重命名为IntVector

// 使用别名
MyInt age = 25;
Distance length = 2.5;
StringPtr name = "John";
IntVector numbers = {1, 2, 3};
```

在这个示例中，我们使用`using`关键字创建了与上述示例中相同的别名，然后使用它们声明变量。

通过创建数据类型别名，你可以使代码更具可读性，尤其在处理复杂数据类型或较长的类型名称时。

### 常量
[开头](#c帮助文档)
在C++中，常量是指在程序执行过程中其值不可改变的数据。常量可以提高代码的可读性和可维护性，并帮助防止无意间对数据的修改。C++中有以下几种类型的常量：

1. 字面常量（Literal Constants）：
   - 整数常量：如`10`、`-5`、`0`等。
   - 浮点常量：如`3.14`、`-0.25`等。
   - 字符常量：用单引号括起来的单个字符，如`'A'`、`'x'`等。
   - 字符串常量：用双引号括起来的一串字符，如`"Hello World"`、`"C++"`等。
   - 布尔常量：`true`和`false`。
   - 空常量：`nullptr`。

2. const修饰的常量：
   - 使用`const`关键字定义的常量，其值一旦初始化就无法修改。
   - 示例：
     ```cpp
     const int MAX_VALUE = 100;
     const double PI = 3.14159;
     ```

3. 枚举常量（Enumeration Constants）：
   - 使用`enum`关键字定义的枚举类型，其中的每个枚举值都是一个常量。
   - 示例：
     ```cpp
     enum Color { RED, GREEN, BLUE };
     Color myColor = RED;
     ```

在使用常量时，可以直接使用字面常量或者通过常量名称来引用。常量提供了一种不可修改的值，可以用于存储固定的、预定义的数据，例如限定范围、常用的数学常数等。

需要注意的是，常量的命名通常采用全大写字母和下划线的组合，以便与变量进行区分，并提高代码的可读性。

### 转义字符
[开头](#c帮助文档)
在C++中，转义字符用于在字符串和字符字面量中插入特殊字符，这些特殊字符通常无法直接键入或表示。转义字符以反斜杠（`\`）开头，后跟一个或多个字符，用于表示特定的转义序列。以下是一些常见的C++转义字符：

1. `\n`：换行符（newline）
2. `\r`：回车符（carriage return）
3. `\t`：制表符（tab）
4. `\'`：单引号（single quote）
5. `\"`：双引号（double quote）
6. `\\`：反斜杠（backslash）
7. `\a`：响铃（alert）
8. `\b`：退格（backspace）
9. `\f`：换页（form feed）
10. `\v`：垂直制表符（vertical tab）
11. `\0`：空字符（null character），通常用于字符串的结尾表示

以下是使用转义字符的示例：
```cpp
cout << "Hello\tWorld\n";  // 输出：Hello    World（制表符和换行符）
cout << "I\'m C++";        // 输出：I'm C++
cout << "C:\\Windows\\System32";  // 输出：C:\Windows\System32
```

需要注意的是，某些转义字符在不同的编译器和系统平台上可能会有所不同，或者可能更多的转义字符可用。确保在编写代码时熟悉相关的转义字符规则以及它们的用法。

### 复合类型
[开头](#c帮助文档)
#### 数组
[开头](#c帮助文档)
C++中的数组是一种用于存储固定大小连续元素的数据结构。数组可以存储相同类型的元素，并通过索引来访问每个元素。以下是一些关于C++数组的基本知识：

1. 声明数组：
   在声明数组时，需要指定元素的数据类型和数组的名称。例如，要声明一个包含5个整数的数组，可以使用以下语法：
   ```cpp
   int myArray[5];
   ```
   
2. 初始化数组：
   数组可以在声明时进行初始化，也可以后续进行赋值。常见的初始化方法有两种：
   1. 使用大括号初始化：可以使用大括号来指定数组的初始值。
   ```cpp
   int myArray[5] = {1, 2, 3, 4, 5};
   ```
   2. 逐个赋值：可以通过循环或逐个赋值的方式给数组元素赋值。
   ```cpp
   int myArray[5];
   myArray[0] = 1;
   myArray[1] = 2;
   // ...
   ```
   
3. 访问数组元素：
   数组的元素可以通过索引访问，索引从0开始，依次递增。例如，要访问数组的第三个元素，可以使用以下语法：
   ```cpp
   int value = myArray[2];
   ```
   其中，`myArray[2]`表示数组的第三个元素。

4. 数组大小：
   数组的大小是在声明数组时指定的，一旦确定，大小就不能改变。可以使用`sizeof`运算符来获取数组的大小。
   ```cpp
   int size = sizeof(myArray) / sizeof(myArray[0]);
   ```
   上述代码将计算数组的大小，并将结果存储在`size`变量中。

5. 注意事项：
   1. 数组的索引必须在合法的范围内，否则可能导致访问越界的错误。
   2. C++还提供了一些方便的数组处理功能，如标准库中的`vector`容器类，它提供了更灵活的数组操作方法。

#### 多维数组
[开头](#c帮助文档)
C++中的多维数组是包含多个维度的数组，可以理解为数组的数组。多维数组可以是二维、三维，甚至更高维度的形式。以下是关于C++多维数组的基本知识：

1. 声明多维数组：
   在声明多维数组时，需要指定每个维度的大小。例如，要声明一个3x3的二维整数数组，可以使用以下语法：
   ```cpp
   int myArray[3][3];
   ```
   
2. 初始化多维数组：
   多维数组可以在声明时进行初始化，也可以后续进行赋值。初始化方法与一维数组类似，可以使用大括号来指定初始值。
   ```cpp
   int myArray[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
   ```

3. 访问多维数组元素：
   多维数组的元素可以通过多个索引来访问，每个索引对应一个维度。例如，要访问二维数组的某个元素，可以使用以下语法：
   ```cpp
   int value = myArray[rowIndex][colIndex];
   ```
   其中，`rowIndex`是行索引，`colIndex`是列索引。

4. 多维数组的循环遍历：
   遍历多维数组可以使用嵌套循环的方式，遍历每个维度的索引。例如，遍历一个3x3的二维数组可以使用以下代码：
   ```cpp
   for (int i = 0; i < 3; i++) {
       for (int j = 0; j < 3; j++) {
           // 访问 myArray[i][j] 并进行相应操作
       }
   }
   ```
   这样可以依次访问每个元素。

5. 注意事项：
   1. 多维数组的每个维度的大小必须在声明时指定，并且各个维度的大小可以不同。
   2. 数组元素和索引都是从0开始的。

#### 枚举体
[开头](#c帮助文档)
在C++中，枚举（enum）是一种用于定义命名常量集合的数据类型。枚举提供了一种更可读和可维护的方法来表示一组相关的命名常量。以下是关于C++枚举体的基本知识：

1. 声明枚举体：
   枚举体可以通过使用`enum`关键字来声明。例如，要声明一个表示星期的枚举体，可以使用以下语法：
   ```cpp
   enum Week {
       Monday,
       Tuesday,
       Wednesday,
       Thursday,
       Friday,
       Saturday,
       Sunday
   };
   ```
   在上述代码中，`Week`是枚举的名称，`Monday`、`Tuesday`等是枚举的成员。

2. 枚举成员：
   枚举的成员是枚举体中的命名常量。每个成员都有一个与之关联的整数值，默认情况下，第一个成员的值为0，后续成员的值依次递增。也可以手动为枚举成员指定值。
   ```cpp
   enum Week {
       Monday = 1,
       Tuesday,
       Wednesday = 5,
       Thursday,
       Friday,
       Saturday,
       Sunday = 0
   };
   ```

3. 使用枚举：
   声明枚举后，我们可以使用枚举体的名称和成员来定义变量。例如：
   ```cpp
   Week today = Tuesday;
   ```

4. 枚举的作用域：
   枚举的作用域是在定义时的大括号内，可以在枚举体定义之外的任何地方使用枚举类型。

5. 枚举的转换：
   枚举可以与整数类型进行相互转换。可以将枚举值赋给整数变量，也可以将整数值赋给枚举变量。但是，建议在进行转换时要小心，确保值的有效性。

枚举体提供了一种更具可读性和可维护性的方式来定义一组相关的常量。

#### 结构体
[开头](#c帮助文档)
在C++中，结构体（struct）是一种用户自定义的数据类型，允许将不同类型的数据组合在一起，形成一个结构体对象。结构体常用于表示一个具有多个相关属性的实体，类似于一个记录或一个数据包。以下是关于C++结构体的基本知识：

1. 声明结构体：
   结构体可以通过使用`struct`关键字来声明。例如，要声明一个表示学生的结构体，可以使用以下语法：
   ```cpp
   struct Student {
       int id;
       std::string name;
       int age;
       double gpa;
   };
   ```
   在上述代码中，`Student`是结构体的名称，`id`、`name`、`age`和`gpa`是结构体的成员。

2. 结构体成员：
   结构体的成员可以是不同的数据类型，可以是内置类型（如`int`、`double`等），也可以是其他自定义类型。成员可以包括变量、数组、指针等。
   
3. 结构体变量的定义和初始化：
   结构体定义后，可以通过结构体名称加变量名的方式定义结构体变量，并对变量进行初始化。例如：
   ```cpp
   Student s1; // 定义一个名为s1的Student结构体变量
   s1.id = 1;
   s1.name = "Tom";
   s1.age = 20;
   s1.gpa = 3.8;
   ```

4. 使用结构体：
   可以使用结构体变量和成员来访问和操作结构体的数据。例如：
   ```cpp
   std::cout << "Student ID: " << s1.id << std::endl;
   std::cout << "Student Name: " << s1.name << std::endl;
   ```

5. 结构体作为函数参数：
   结构体可以作为参数传递给函数，可以按值传递或按引用传递。按值传递会进行结构体的拷贝，而按引用传递会避免额外的拷贝开销。

结构体提供了一种组织和管理数据的方式，允许将多个相关属性组合在一起。


#### 共用体
[开头](#c帮助文档)
在C++中，共用体（union）是一种特殊的数据类型，允许在同一内存位置存储不同的数据类型，但只能同时存储其中的一个。共用体的大小取决于最大的成员大小。以下是关于C++共用体的基本知识：

1. 声明共用体：
   共用体可以通过使用`union`关键字来声明。例如，要声明一个共用体来存储整型和浮点型数据，可以使用以下语法：
   ```cpp
   union Data {
       int intValue;
       float floatValue;
   };
   ```
   在上述代码中，`Data`是共用体的名称，`intValue`和`floatValue`是共用体的成员。

2. 共用体成员：
   共用体可以有多个成员，每个成员可以是不同的数据类型。共用体的所有成员共享相同的内存空间。

3. 共用体的使用：
   共用体只能同时存储其成员中的一个值。通过设置一个成员值，会覆盖之前存储的值。例如：
   ```cpp
   Data data;
   data.intValue = 10;
   std::cout << "Integer value: " << data.intValue << std::endl;
   data.floatValue = 3.14;
   std::cout << "Float value: " << data.floatValue << std::endl;
   ```

4. 共用体的内存使用：
   共用体的大小等于其中最大成员的大小。共用体的大小取决于存储的成员类型，但共用体的总大小足够容纳最大成员类型的大小。

5. 注意事项：
   1. 在访问共用体成员时，只能访问当前存储的成员值，访问其他成员的值会导致未定义的行为。
   2. 共用体在某些情况下可以用于节省内存，但也需要小心使用，以确保正确管理和访问共用体的数据。

共用体提供了一种存储不同数据类型的灵活方式，但需要在使用时注意存储的值类型和访问的正确性。

### 指针
[开头](#c帮助文档)
在C++中，指针（Pointer）是一种特殊的变量类型，它存储了一个内存地址，可以用来访问内存中的数据。指针提供了直接访问内存的能力，允许通过地址来操作变量。

以下是一个简单的指针的示例：

```cpp
int main() {
    int num = 10;
    int* ptr = &num;

    cout << "Value of num: " << num << endl;    // 输出：Value of num: 10
    cout << "Address of num: " << &num << endl; // 输出：Address of num: 0x7ffee01a4abc
    cout << "Value of ptr: " << ptr << endl;    // 输出：Value of ptr: 0x7ffee01a4abc
    cout << "Value at the address ptr is pointing to: " << *ptr << endl;  // 输出：Value at the address ptr is pointing to: 10

    return 0;
}
```

在上述示例中，我们首先声明了一个 `num` 变量，它存储一个整数值 10。然后，我们声明了一个指针 `ptr`，使用取地址运算符 `&` 将 `num` 的地址赋值给 `ptr`。通过 `*ptr` 可以访问 `ptr` 指向的地址处的值。

指针和变量之间通过赋值操作相互关联。将指针指向变量的地址，可以通过指针访问和操作该变量的值。

指针的常见操作包括以下内容：

- 获取变量的地址：使用取地址运算符 `&`，例如 `&num`。
- 声明指针变量：使用指针类型（如 `int*`）声明一个指针变量，例如 `int* ptr;`。
- 将指针指向变量的地址：将变量的地址赋值给指针变量，例如 `ptr = &num;`。
- 通过指针访问变量的值：使用解引用运算符 `*`，例如 `*ptr`。
- 修改指针指向的变量的值：通过指针修改变量的值，例如 `*ptr = 20;`。

需要注意的是，使用指针时要小心处理空指针和野指针的问题，以避免未定义的行为和程序崩溃。

指针在C++中被广泛用于动态内存分配、数组和字符串处理、函数传递参数的引用传递、对象的动态创建和销毁等方面。它是C++中重要的概念之一，也是C++相较于其他语言的一个特点之一。

## string类
[开头](#c帮助文档)
在C++中，使用std::string类需要包含头文件<string>。该头文件定义了std::string类及其相关操作的声明和定义。要在C++程序中使用std::string类，可以通过以下方式包含头文件：
```cpp
#include <string>
```
这样就可以在程序中使用std::string类及其相关功能了
在C++中，`std::string`是一个标准库类，用于处理字符串。它提供了一系列方法和操作符，可以方便地对字符串进行操作和处理。以下是一些`std::string`类的主要功能：

1. 创建和初始化字符串：
   可以使用多种方式创建和初始化`std::string`对象，包括直接赋值、使用字符数组初始化、使用其他字符串对象初始化等。例如：
   ```cpp
   std::string s1 = "Hello"; // 直接赋值
   std::string s2("World"); // 使用字符数组初始化
   std::string s3 = s1 + " " + s2; // 使用其他字符串对象初始化
   ```

2. 访问和修改字符串内容：
   `std::string`提供了多种方法来访问和修改字符串的内容。可以使用下标操作符`[]`、`at()`函数或迭代器来访问单个字符，可以使用`substr()`函数获得子字符串的副本，可以使用`size()`函数获取字符串长度，等等。例如：
   ```cpp
   std::string s = "Hello";
   char c = s[0]; // 访问第一个字符
   s[0] = 'h'; // 修改第一个字符为小写
   std::string sub = s.substr(1, 3); // 获取子字符串 "ell"
   int length = s.size(); // 获取字符串长度
   ```

3. 字符串的连接和拼接：
   `std::string`支持使用`+`操作符进行字符串的连接和拼接。可以将两个字符串通过`+`操作符连接为一个新的字符串，也可以将其他类型的数据直接与字符串相加，实现类型转换和拼接。例如：
   ```cpp
   std::string s1 = "Hello";
   std::string s2 = "World";
   std::string s3 = s1 + " " + s2; // 字符串连接
   int age = 20;
   std::string message = "I am " + std::to_string(age) + " years old."; // 类型转换和拼接
   ```

4. 字符串的查找和替换：
   `std::string`提供了多种函数用于字符串的查找和替换操作。可以使用`find()`函数查找子字符串在原字符串中的位置，可以使用`replace()`函数替换指定部分的字符串，等等。例如：
   ```cpp
   std::string s = "Hello, World";
   size_t pos = s.find("World"); // 查找子字符串 "World" 的位置
   s.replace(pos, 5, "Universe"); // 替换子字符串为 "Universe"
   ```

5. 其他功能：
   `std::string`还提供了其他一些有用的功能，如比较运算符来比较字符串的大小、空字符串的检测、字符串的大小写转换等。你可以根据需要查阅相关文档以获取更多细节。

`std::string`类是C++中用于处理字符串的重要工具。它提供了方便的接口和丰富的功能，可以大大简化字符串处理的任务。

## 运算符
[开头](#c帮助文档)

以下是C++中的所有运算符及其示例：

1. 算术运算符：
   - 加法运算符（+）：将两个数相加。
   - 减法运算符（-）：从一个数中减去另一个数。
   - 乘法运算符（*）：将两个数相乘。
   - 除法运算符（/）：将一个数除以另一个数。
   - 取模运算符（%）：取两个数相除的余数。

   示例：
   ```cpp
   int a = 10;
   int b = 3;
   int sum = a + b; // sum的值为13
   int difference = a - b; // difference的值为7
   int product = a * b; // product的值为30
   int quotient = a / b; // quotient的值为3
   int remainder = a % b; // remainder的值为1
   ```

2. 关系运算符：
   - 相等运算符（==）：判断两个操作数是否相等。
   - 不等运算符（!=）：判断两个操作数是否不相等。
   - 大于运算符（>）：判断第一个操作数是否大于第二个操作数。
   - 小于运算符（<）：判断第一个操作数是否小于第二个操作数。
   - 大于等于运算符（>=）：判断第一个操作数是否大于等于第二个操作数。
   - 小于等于运算符（<=）：判断第一个操作数是否小于等于第二个操作数。

   示例：
   ```cpp
   int a = 5;
   int b = 3;
   bool isEqual = (a == b); // isEqual的值为false
   bool isNotEqual = (a != b); // isNotEqual的值为true
   bool isGreater = (a > b); // isGreater的值为true
   bool isLess = (a < b); // isLess的值为false
   bool isGreaterOrEqual = (a >= b); // isGreaterOrEqual的值为true
   bool isLessOrEqual = (a <= b); // isLessOrEqual的值为false
   ```

3. 逻辑运算符：
   - 逻辑与运算符（&&）：用于判断两个条件是否同时成立。
   - 逻辑或运算符（||）：用于判断两个条件是否至少有一个成立。
   - 逻辑非运算符（!）：用于取反一个条件的值。

   示例：
   ```cpp
   bool condition1 = true;
   bool condition2 = false;
   bool resultAnd = (condition1 && condition2); // resultAnd的值为false
   bool resultOr = (condition1 || condition2); // resultOr的值为true
   bool resultNot = !condition1; // resultNot的值为false
   ```

4. 位运算符：
   - 按位与运算符（&）：对两个操作数进行按位与操作。
   - 按位或运算符（|）：对两个操作数进行按位或操作。
   - 按位异或运算符（^）：对两个操作数进行按位异或操作。
   - 按位取反运算符（~）：对操作数进行按位取反操作。
   - 左移运算符（<<）：将一个数的二进制表示左移指定位数。
   - 右移运算符（>>）：将一个数的二进制表示右移指定位数。

   示例：
```cpp
   int a = 5; // 二进制表示为 101
   int b = 3; // 二进制表示为 011
   int resultAnd = a & b; // resultAnd的值为 001 (1)
   int resultOr = a | b; // resultOr的值为 111 (7)
   int resultXor = a ^ b; // resultXor的值为 110 (6)
   int resultNot = ~a; // resultNot的值为 -6 (补码表示)
   int c= 5;  // 二进制表示: 00101
   int result = c<< 2;  // 二进制表示: 10100 (结果为20)
   int d = 20;  // 二进制表示: 10100
   int resultd= d >> 2;  // 二进制表示: 00101 (结果为5)
```
   5. 赋值运算符：
   - 简单赋值运算符（=）：将右边表达式的值赋给左边的变量。
   - 复合赋值运算符（+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=）：将右边表达式的值与左边的变量进行相应运算，并将结果赋给左边的变量。

   示例：
   ```cpp
   int a = 5;
   int b = 3;
   a += b; // a的值变为8
   int c = 10;
   c -= 5; // c的值变为5
   int d = 4;
   d *= 2; // d的值变为8
   int e = 10;
   e /= 2; // e的值变为5
   int f = 7;
   f %= 3; // f的值变为1
   ```

6. 自增和自减运算符：
   - 自增运算符（++）：将变量的值增加1。
   - 自减运算符（--）：将变量的值减少1。

   示例：
   ```cpp
   int a = 5;
   a++; // a的值变为6
   int b = 3;
   b--; // b的值变为2
   ```

7. 条件运算符：
   - 三元条件运算符（?:）：根据条件选择两个表达式中的一个进行计算。

   示例：
   ```cpp
   int a = 5;
   int b = 3;
   int max = (a > b) ? a : b; // 如果a > b, 则返回a，否则返回b
   ```

8. 成员访问和指针运算符：
   - 成员访问运算符（.）：访问类的成员变量和成员函数。
   - 指针成员访问运算符（->）：通过指针访问类的成员变量和成员函数。

   示例：
   ```cpp
   struct Point {
       int x;
       int y;
   };

   Point p;
   p.x = 10; // 使用成员访问运算符设置成员变量的值
   p.y = 5;
   Point* ptr = &p; // 创建指向Point结构体的指针
   ptr->x = 20; // 使用指针成员访问运算符设置成员变量的值
   ptr->y = 15;
   ```

9. 数组下标运算符（[]）：访问数组中的元素。

   示例：
   ```cpp
   int arr[5] = {1, 2, 3, 4, 5};
   int element = arr[2]; // 获取数组中下标为2的元素，值为3
   ```

10. 指针运算符：
    - 取地址运算符（&）：返回变量的地址。
    - 解引用运算符（*）：通过指针访问指针所指向的变量。

    示例：
    ```cpp
    int a = 5;
    int* ptr = &a; // 创建指向变量a的指针
    int value = *ptr; // 解引用指针，获取指针所指向的变量的值
    ```

11. sizeof运算符：返回数据类型或变量的大小（以字节为单位）。

    示例：
    ```cpp
    int age = 25;
    size_t size = sizeof(age); // 获取变量age的大小

    int arr[5];
    size_t arrSize = sizeof(arr); // 获取数组arr的大小

    struct Person {
        char name[20];
        int age;
    };
    size_t structSize = sizeof(Person); // 获取结构体Person的大小
    ```

12. 逗号运算符（,）：用于在表达式中分隔多个子表达式，返回最后一个表达式的值。

    示例：
    ```cpp
    int a = 5, b = 10, c = 15;
    int result = (a += b, b += c, c += a); // 先计算a+=b, 然后b+=c, 最后c+=a，result的值为20
    ```

13. 强制类型转换运算符：
    - C风格转换运算符（类型）：将一个值强制转换为指定的类型。
    - static_cast<类型>：进行静态类型转换。
    - dynamic_cast<类型>：进行动态类型转换。
    - const_cast<类型>：去除变量的常量性。
    - reinterpret_cast<类型>：进行底层（位）重新解释类型转换。

    示例：
    ```cpp
    double a = 3.14;
    int b = (int)a; // 使用C风格转换运算符将double类型转换为int类型

    double c = 5.67;
    int d = static_cast<int>(c); // 使用static_cast进行静态类型转换
    
    Base* basePtr = new Derived(); // Base是派生类的基类
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr); // 使用dynamic_cast进行动态类型转换

    const int x = 10;
    int* y = const_cast<int*>(&x); // 使用const_cast去除变量的常量性

    int* z = reinterpret_cast<int*>(basePtr); // 使用reinterpret_cast进行底层重新解释类型转换
    ```

运算符是用于执行各种操作和计算的关键工具，熟悉它们可以帮助你编写更有效和灵活的代码。

## 运算符优先级
[开头](#c帮助文档)
以下是C++中所有运算符的优先级讲解和表格展示：

| 优先级 | 运算符                             | 描述                                         |
| ------ | ---------------------------------- | -------------------------------------------- |
| 1      | ::                                 | 域解析（作用域限定符）                       |
| 2      | ++ --                              | 递增/递减操作符                              |
| 3      | !                                  | 逻辑非                                       |
| 4      | * / %                              | 乘法、除法、取余                             |
| 5      | + -                                | 加法、减法                                   |
| 6      | << >>                              | 位左移、位右移                               |
| 7      | < <= > >=                          | 关系运算符，小于、小于等于、大于、大于等于   |
| 8      | == !=                              | 关系运算符，等于、不等于                     |
| 9      | &                                  | 按位与                                       |
| 10     | ^                                  | 按位异或                                     |
| 11     | \|                                 | 按位或                                       |
| 12     | &&                                 | 逻辑与                                       |
| 13     | \|\|                               | 逻辑或                                       |
| 14     | ?:                                 | 条件运算符（三元运算符），用于条件判断和赋值 |
| 15     | = += -= *= /= %= <<= >>= &= ^= \|= | 赋值运算符及其组合形式                       |
| 16     | ,                                  | 逗号运算符，用于分隔表达式和函数参数         |

需要注意的是，表格中运算符的优先级较低的会在计算顺序上位于优先级较高的运算符之后。在表达式中，可以使用小括号 `( )` 来改变运算符的优先级，括号中的表达式会先被求值。

这只是C++中常见的运算符优先级的总结，具体优先级还与操作数的类型和运算符组合等因素有关。详情可以参考C++语言规范或相关文档。
## 分支语句
[开头](#c帮助文档)
在C++中，分支语句用于根据条件执行不同的代码块。其中，if语句和switch语句是两种常用的分支语句。

1. **if语句**：用于根据条件执行不同的代码块。

  在C++中，if语句是一种常用的分支语句，用于根据条件判断是否执行某个代码块。if语句的一般语法形式如下：

```cpp
if (condition) {
    // 如果条件为真，则执行这里的代码块
}
```

其中，`condition` 是一个表达式，当其值为`true`时，执行`if`语句后面的代码块。如果`condition`的值为`false`，则跳过代码块，继续执行后续的代码。

if语句也可以与`else`关键字结合使用，提供一个分支，用于在条件为`false`时执行另一段代码。if-else的语法形式如下：

```cpp
if (condition) {
    // 如果条件为真，则执行这里的代码块
}
else {
    // 如果条件为假，则执行这里的代码块
}
```

示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    int num = 10;
    if (num > 0) {
        cout << "The number is positive." << endl;
    }
    else {
        cout << "The number is non-positive." << endl;
    }
    return 0;
}
```

输出：
```
The number is positive.
```

在C++中，你还可以使用 `else if` 结构来添加多个条件判断，形成更复杂的逻辑。

```cpp
if (condition1) {
    // 如果条件1为真，则执行这里的代码块
}
else if (condition2) {
    // 如果条件1为假且条件2为真，则执行这里的代码块
}
else {
    // 当前面的条件都为假时执行这里的代码块
}
```

示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    int num = 0;
    if (num > 0) {
        cout << "The number is positive." << endl;
    }
    else if (num < 0) {
        cout << "The number is negative." << endl;
    }
    else {
        cout << "The number is zero." << endl;
    }
    return 0;
}
```

输出：
```
The number is zero.
```

if语句是在代码中进行条件判断和控制流程的重要工具，使得程序能够在不同的条件下执行不同的操作，具有很高的灵活性。

2. **switch语句**：用于根据表达式的值执行不同的代码块。

 在C++中，switch语句是一种常用的分支语句，用于根据表达式的值执行不同的代码块。switch语句的一般语法形式如下：

```cpp
switch (expression) {
    case value1:
        // 如果 expression 的值与 value1 匹配，则执行这里的代码块
        break;
    case value2:
        // 如果 expression 的值与 value2 匹配，则执行这里的代码块
        break;
    // 可以继续添加更多的 case 分支
    default:
        // 如果 expression 的值与前面的所有 case 都不匹配，则执行这里的代码块
        break;
}
```

其中，`expression` 是一个表达式，它的值将与每个 `case` 分支后面的 `value` 进行比较，以确定应该执行哪个代码块。当 `expression` 的值与某个 `case` 分支的 `value` 匹配时，将从该分支开始执行代码，并执行该分支后面的所有代码，直到遇到 `break` 关键字，或者直到 `switch` 语句结束。

如果 `expression` 的值与所有的 `case` 分支都不匹配，那么将执行 `default` 分支后面的代码块。

示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    int day = 3;
    switch (day) {
        case 1:
            cout << "Monday" << endl;
            break;
        case 2:
            cout << "Tuesday" << endl;
            break;
        case 3:
            cout << "Wednesday" << endl;
            break;
        case 4:
            cout << "Thursday" << endl;
            break;
        case 5:
            cout << "Friday" << endl;
            break;
        default:
            cout << "Invalid day" << endl;
            break;
    }
    return 0;
}
```

输出：
```
Wednesday
```

在switch语句中，每个case分支后面的代码块通常以 `break` 关键字结束，这是为了防止执行其他的case分支。如果省略了break语句，将会继续执行紧跟在匹配的case分支后面的代码，直到遇到break或者switch语句结束。

使用switch语句可以简化对一个表达式的多个可能值进行判断的代码，提高代码的可读性和可维护性。需要注意的是，switch语句只适用于判断某个变量的取值，不适用于判断条件表达式的结果。

if语句和switch语句是根据不同的条件执行不同的代码块。if语句适用于多个条件需要判断的情况，而switch语句适用于根据表达式的值进行选择的情况。根据实际需求选择合适的分支语句可以增加程序的灵活性和可读性。

## 循环语句
[开头](#c帮助文档)
在C++中，循环语句允许重复执行一段代码，直到满足特定的条件为止。C++提供了几种类型的循环语句，包括for循环、while循环和do-while循环。下面是每种循环语句的示例：

1. **for循环**

在C++中，for循环是一种常用的循环语句，用于指定循环的初始条件、循环条件和每次循环的增量。for循环的语法形式如下：

```cpp
for (initialization; condition; increment/decrement) {
    // 在每次循环中执行的代码块
}
```

其中，`initialization` 是循环的初始条件，只在循环开始之前执行一次。`condition` 是循环条件，每次循环开始前都会检查。如果条件为真，则执行循环中的代码块；如果条件为假，则跳出循环。`increment/decrement` 是循环增量或减量，在每次循环后执行。

示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 5; i++) {
        cout << "Count: " << i << endl;
    }
    return 0;
}
```

输出：
```
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
```

在上述示例中，`i = 1` 是初始条件，`i <= 5` 是条件，`i++` 是每次循环的增量。循环从 `i = 1` 开始，每次循环时将打印出当前的计数器值并递增，直到 `i` 不再满足条件 `i <= 5` 为止。

在for循环中，初始条件、条件和增量可以是任意合法的表达式。可以使用for循环来遍历数组、处理连续的数字范围、重复执行特定次数的操作等。但需要注意的是，循环变量的作用域仅限于for循环内部。

此外，在C++中，使用for循环还可以很方便地遍历数组、字符串、向量等容器类对象的元素。这种形式的循环被称为范围for循环（range-based for loop）或foreach循环。它的语法形式如下：

```cpp
for (type variable : container) {
    // 循环中针对每个元素执行的代码
}
```

其中，`type` 是容器中元素的类型，`variable` 是一个新声明的变量，用来表示当前遍历到的元素。`container` 则是待遍历的容器对象。

示例1：遍历数组
```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    for (int num : arr) {
        cout << num << " ";
    }
    return 0;
}
```

输出：
```
1 2 3 4 5
```

示例2：遍历字符串
```cpp
#include <iostream>
using namespace std;

int main() {
    string str = "Hello";
    for (char ch : str) {
        cout << ch << " ";
    }
    return 0;
}
```

输出：
```
H e l l o
```

范围for循环会自动遍历容器中的每个元素，并将当前元素赋值给声明的变量进行处理。通过这种方式，我们可以遍历数组、字符串、向量等容器对象，无需手动管理索引和判断循环条件，减少了代码的复杂性。

2. **while循环**
   
在C++中，while循环是一种常用的循环语句，用于在满足特定条件时重复执行一段代码。while循环的语法形式如下：

```cpp
while (condition) {
    // 在条件为真时执行的代码块
}
```

其中，`condition` 是一个表达式，每次循环开始前都会被检查。如果条件为真，则执行循环中的代码块；如果条件为假，则跳出循环。

示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    int i = 1;
    while (i <= 5) {
        cout << "Count: " << i << endl;
        i++;
    }
    return 0;
}
```

输出：
```
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
```

在上述示例中，`i <= 5` 是条件，每次循环开始前都会检查这个条件。当条件为真时，执行输出语句和增量操作 `i++`。当条件为假时，跳出循环。

需要注意的是，如果循环条件一开始就为假，则循环体内的代码将一次也不会执行。

在循环体内，可以根据需要进行其他操作，如输入、计算或条件判断。循环条件的判断可以基于各种条件表达式，只要能够得到布尔值的表达式都可以作为条件。

使用while循环时，需要确保循环条件可以被改变，以免造成无限循环。可以在循环体内修改循环条件，以便在满足某种条件时退出循环。

总结起来，while循环适用于在未知循环次数的情况下，根据条件重复执行一段代码，直到条件为假为止。

3. **do while循环**

在C++中，do-while循环是一种循环语句，类似于while循环，但与while循环的一个主要区别是，do-while循环保证循环体内的代码至少执行一次。do-while循环的基本语法如下：

```cpp
do {
    // 在循环中执行的代码块
} while (condition);
```

首先，循环体内的代码块会被执行，然后检查循环条件。如果条件为真，则继续执行循环，否则跳出循环。

示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    int i = 1;
    do {
        cout << "Count: " << i << endl;
        i++;
    } while (i <= 5);
    return 0;
}
```

输出：
```
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
```

在上述示例中，循环体中的代码块会先执行，然后检查循环条件 `i <= 5`。因为初始值 `i` 是1，满足条件，所以继续执行循环。之后，在每次循环结束后再次检查条件，如果条件为真，则继续执行循环；如果条件为假，则跳出循环。

do-while循环适用于需要执行某个操作，然后基于条件判断是否继续执行的情况。因为循环体内的代码至少执行一次，所以do-while循环常用于需要读取用户输入并进行处理的场景。

需要注意的是，在循环体内部，可以根据需要进行条件判断、计算或其他操作。循环条件应该能够在循环体执行后进行修改，以便在满足终止条件时退出循环。

总结起来，do-while循环在执行循环之前不会检查条件，且保证循环体内的代码至少执行一次。在需要至少执行一次循环的情况下，可以使用do-while循环。

4. **break语句和continue语句**
   
在C++中，`break`和`continue`是用于控制循环的两个关键字，它们的作用如下：

1. `break`语句：`break`语句用于立即终止当前所在的循环，并跳出循环的执行体，继续执行循环之后的代码。`break`常用于满足某个条件时提前结束循环，或者在想要跳出多重嵌套循环时使用。

   示例：
   ```cpp
   for (int i = 0; i < 10; i++) {
       if (i == 5) {
           break; // 当 i 等于 5 时终止循环
       }
       cout << i << " ";
   }
   // 输出: 0 1 2 3 4
   ```

2. `continue`语句：`continue`语句用于跳过当前迭代中剩余的代码，并立即进入下一次迭代。它会跳过循环体内`continue`语句之后的代码，并直接进行下一次的迭代判断。

   示例：
   ```cpp
   for (int i = 0; i < 10; i++) {
       if (i == 5) {
           continue; // 当 i 等于 5 时跳过当前迭代，进入下一次迭代
       }
       cout << i << " ";
   }
   // 输出: 0 1 2 3 4 6 7 8 9
   ```

`break`和`continue`通常与循环结构（如`for`、`while`、`do-while`）一起使用。它们提供了更精细的循环控制，允许在满足特定条件时立即终止循环或跳过当前迭代的执行。通过合理使用`break`和`continue`语句，可以增强程序的灵活性和效率。

## goto语句
[开头](#c帮助文档)
在C++中，`goto`语句是一种跳转语句，它可以将程序的控制流无条件跳转到指定的标签位置。`goto`语句的使用在现代C++编程中被认为是一种不良的实践，并且通常被避免使用，因为它可能会导致代码变得难以理解、难以维护和容易产生错误。建议在编写代码时避免使用`goto`语句。

`goto`语句的语法如下：

```cpp
goto label;

// ...

label:
// 执行到这里时的代码
```

以下是一个简单的例子，展示了`goto`语句的使用：

```cpp
#include <iostream>
using namespace std;

int main() {
    int num = 0;

    start:
    num++;
    cout << "Number: " << num << endl;

    if (num < 5)
        goto start;

    return 0;
}
```

上述代码中，当变量`num`小于5时，程序会跳转到标签`start`处，并增加`num`的值，然后打印输出。这个过程会一直重复，直到`num`不再小于5。

需要强调的是，虽然`goto`语句在某些特定情况下可能有用，但在大多数情况下，使用结构化的控制流语句（如循环和条件语句）会更好地组织和管理代码。这样可以提高代码的可读性和可维护性。

## 函数
### 库函数
在C++中，库函数（Library Functions）是事先编写好并打包在库文件中的可重用代码模块，用于实现常见的功能和算法。这些库函数提供了一系列的接口和操作，可以方便地在程序中调用和使用。

C++的库函数分为两种类型：

1. **标准库函数**：也称为C++标准库（C++ Standard Library），是由C++语言规范所定义的标准库。它包含了大量的类、函数和算法，按照功能可分为以下几个头文件：

   - **iostream**：用于输入输出操作，包括控制台输入输出、文件输入输出等。
   - **string**：用于字符串操作，包括字符串处理、查找、替换等。
   - **vector**：用于动态数组操作，包括数组的增删改查、排序等。
   - **algorithm**：提供了常用的算法函数，如排序、查找、计数等。
   - **map** 和 **unordered_map**：用于创建键值对映射的容器。
   - **set** 和 **unordered_set**：用于创建不重复元素的容器。
   - 还有其他头文件，提供了更多功能和数据结构的支持。

2. **扩展库函数**：由第三方开发者或组织提供的库函数，用于实现特定的功能或算法。这些库函数可能是一些常见任务的封装，也可能是一些特定领域的库函数，如图形处理、网络编程、数据库访问等。常见的扩展库包括Boost、Qt、OpenCV等。

使用库函数可以大大简化程序开发过程，避免重复编写相同的代码，提高开发效率和代码的可重用性。在编写C++程序时，可以根据需要引入相应的库函数，并根据库函数的文档和接口规范来调用和使用。
#### iostream
[开头](#c帮助文档)
以下是C++ `iostream`头文件中的所有函数的详细信息（包括函数名、函数原型、描述和使用示例）：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| --- | --- | --- | --- |
| cin | istream& cin | 标准输入流对象，用于从控制台或其他输入源读取数据。 | int num; cin >> num; |
| cout | ostream& cout | 标准输出流对象，用于将数据输出到控制台或其他输出源。 | cout << "Hello, world!"; |
| cerr | ostream& cerr | 标准错误流对象，用于将错误信息输出到控制台或其他错误输出源。 | cerr << "Error occurred"; |
| clog | ostream& clog | 标准日志流对象，用于将日志信息输出到控制台或其他日志输出源。 | clog << "Log message"; |
| endl | ostream& endl(ostream& os) | 在输出流中插入换行符，并刷新流。 | cout << "Hello" << endl; |
| flush | ostream& flush(ostream& os) | 刷新输出流，确保缓冲区中的数据写入目标设备。 | cout << "Flush" << flush; |
| get | istream& get(char& c) | 从输入流中获取下一个字符并存储到变量中。 | char ch; cin.get(ch); |
| getline | istream& getline(istream& is, string& str) | 从输入流中按行读取字符串。 | string line; getline(cin, line); |
| put | ostream& put(char c) | 将字符写入输出流。 | cout.put('A'); |
| write | ostream& write(const char* s, streamsize n) | 将指定长度的字符写入输出流。 | const char* text = "Hello"; cout.write(text, 5); |
| ignore | istream& ignore(streamsize n = 1, int delim = EOF) | 从输入流中忽略指定数量的字符。 | cin.ignore(100, '\n'); |
| peek | int peek() | 返回当前输入流的下一个字符，但不提取它。 | if (cin.peek() == 'A') { // do something } |
| read | istream& read(char* s, streamsize n) | 从输入流中读取指定长度的字符并存储到字符数组中。 | char buffer[256]; cin.read(buffer, 255); |
| seekg | istream& seekg(streampos pos) | 在输入流中设置当前读取位置。 | ifstream file("example.txt"); file.seekg(10); |
| seekp | ostream& seekp(streampos pos) | 在输出流中设置当前写入位置。 | ofstream file("output.txt"); file.seekp(5); |
| tellg | streampos tellg() | 返回当前输入流的读取位置。 | ifstream file("example.txt"); streampos pos = file.tellg(); |
| tellp | streampos tellp() | 返回当前输出流的写入位置。 | ofstream file("output.txt"); streampos pos = file.tellp(); |
| putback | istream& putback(char c) | 将字符放回到输入流中。 | char ch = cin.get(); cin.putback(ch); |
| sync | void sync() | 刷新所有关联的输入和输出流。 | cin.sync(); cout.sync(); |
| tie | ostream* tie(ostream* stream) | 关联一个输出流，使得当任何输入操作时，被关联的输出流自动刷新。 | cout << "Hello, world!" << endl; cout.tie(&cerr); |
| rdbuf | streambuf* rdbuf() | 返回与流对象关联的底层字符缓冲区。 | ofstream file("output.txt"); streambuf* buffer = file.rdbuf(); |

这是完整的C++ iostream头文件中的函数列表，包含了更多的函数以及它们的描述和使用示例。
#### iomanip
[开头](#c帮助文档)
以下是C++ `iomanip`头文件中的所有函数的详细信息（包括函数名、函数原型、描述和使用示例）：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| --- | --- | --- | --- |
| setprecision | ostream& setprecision(int n) | 设置浮点数的精度。 | cout << setprecision(2) << fixed << 3.14159; |
| setw | ostream& setw(int n) | 设置下一个输出字段的宽度。 | cout << setw(8) << "Hello"; |
| setfill | ostream& setfill(char c) | 设置用于填充字段的字符。 | cout << setfill('-') << setw(10) << "Hello"; |
| left | ostream& left | 设置输出字段为左对齐方式。 | cout << left << setw(10) << "Hello"; |
| right | ostream& right | 设置输出字段为右对齐方式。 | cout << right << setw(10) << "Hello"; |
| internal | ostream& internal | 设置输出字段为内部对齐方式（正负数符号在字段内部）。 | cout << showpos << internal << setw(6) << 12; |
| boolalpha | ostream& boolalpha | 输出布尔值时，将其显示为"true"或"false"。 | cout << boolalpha << true; |
| noboolalpha | ostream& noboolalpha | 恢复布尔值的默认输出方式。 | cout << noboolalpha << true; |
| showbase | ostream& showbase | 输出整数值时显示其进制前缀。 | cout << showbase << hex << 42; |
| noshowbase | ostream& noshowbase | 恢复整数值的默认输出方式。 | cout << noshowbase << hex << 42; |
| showpoint | ostream& showpoint | 显示浮点数的小数点和尾随零。 | cout << showpoint << fixed << 3.14; |
| noshowpoint | ostream& noshowpoint | 恢复浮点数的默认输出方式。 | cout << noshowpoint << fixed << 3.14; |
| showpos | ostream& showpos | 显示正数的正号。 | cout << showpos << 12; |
| noshowpos | ostream& noshowpos | 恢复正数的默认输出方式。 | cout << noshowpos << 12; |
| uppercase | ostream& uppercase | 将16进制数的字母输出为大写。 | cout << uppercase << hex << 10; |
| nouppercase | ostream& nouppercase | 恢复16进制数的默认输出方式。 | cout << nouppercase << hex << 10; |
| fixed | ostream& fixed | 输出浮点数以固定点表示法显示。 | cout << fixed << 3.14; |
| scientific | ostream& scientific | 输出浮点数以科学计数法显示。 | cout << scientific << 3.14; |
| hex | ostream& hex | 输出整数值为16进制。 | cout << hex << 42; |
| dec | ostream& dec | 恢复整数值的默认输出方式。 | cout << dec << 42; |
| oct | ostream& oct | 输出整数值为8进制。 | cout << oct << 42; |
| resetiosflags | ostream& resetiosflags(ios_base::fmtflags flags) | 将指定的输出格式标志复位为默认值。 | cout << resetiosflags(ios::scientific); |

这是C++ `iomanip`头文件中的所有函数的详细信息。
#### fstream
[开头](#c帮助文档)
以下是C++ `fstream`头文件中的所有函数的详细信息（包括函数名、函数原型、描述和使用示例）：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| --- | --- | --- | --- |
| open | void open(const char* filename, ios_base::openmode mode = ios_base::in\|ios_base::out) | 打开文件，并将其与流对象关联。 | fstream file; file.open("example.txt", ios::in); |
| is_open | bool is_open() const | 检查文件是否成功打开。 | ifstream file; if (file.is_open()) { // do something } |
| close | void close() | 关闭与流对象关联的文件。 | ofstream file; file.open("output.txt"); file.close(); |
| flush | ostream& flush() | 刷新输出流，确保缓冲区中的数据写入文件。 | ofstream file; file << "Hello"; file.flush(); |
| tellg | streampos tellg() | 返回当前读取位置在文件中的绝对位置。 | ifstream file; streampos pos = file.tellg(); |
| seekg | istream& seekg(streampos pos) | 设置当前读取位置在文件中的绝对位置。 | ifstream file; file.seekg(100); |
| tellp | streampos tellp() | 返回当前写入位置在文件中的绝对位置。 | ofstream file; streampos pos = file.tellp(); |
| seekp | ostream& seekp(streampos pos) | 设置当前写入位置在文件中的绝对位置。 | ofstream file; file.seekp(200); |
| write | ostream& write(const char* s, streamsize n) | 将指定长度的字符写入文件。 | ofstream file; const char* text = "Hello"; file.write(text, 5); |
| read | istream& read(char* s, streamsize n) | 从文件中读取指定长度的字符。 | ifstream file; char buffer[256]; file.read(buffer, 255); |
| getline | istream& getline(istream& is, string& str) | 从文件中按行读取字符串。 | ifstream file; string line; getline(file, line); |
| operator<< | ostream& operator<<(ostream& os, T& val) | 重载输出操作符，用于将数据写入文件。 | ofstream file; int num = 42; file << num; |
| operator>> | istream& operator>>(istream& is, T& val) | 重载输入操作符，用于从文件中读取数据。 | ifstream file; int num; file >> num; |
| good | bool good() const | 检测流对象是否处于可用状态。 | fstream file; if (file.good()) { // do something } |
| bad | bool bad() const | 检测流对象是否处于错误状态。 | fstream file; if (file.bad()) { // handle error } |
| fail | bool fail() const | 检测流对象是否处于失败状态。 | fstream file; if (file.fail()) { // handle failure } |
| eof | bool eof() const | 检测流对象是否已达到文件末尾。 | fstream file; if (file.eof()) { // handle end of file } |
| clear | void clear(iostate state = goodbit) | 清除流对象的状态标志。 | fstream file; file.clear(); |

这是C++ `fstream`头文件中的所有函数的详细信息。
#### cmath
[开头](#c帮助文档)
以下是C++ `cmath`头文件中的所有函数的详细信息（包括函数名、函数原型、描述和使用示例）：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| --- | --- | --- | --- |
| abs | int abs(int x) <br> long abs(long x) <br> float abs(float x) <br> double abs(double x) <br> long double abs(long double x) | 返回参数的绝对值。 | int result = abs(-5); |
| acos | double acos(double x) | 返回参数的反余弦值，以弧度表示。 | double result = acos(0.5); |
| asin | double asin(double x) | 返回参数的反正弦值，以弧度表示。 | double result = asin(0.5); |
| atan | double atan(double x) | 返回参数的反正切值，以弧度表示。 | double result = atan(0.5); |
| atan2 | double atan2(double y, double x) | 返回给定的直角坐标(x, y)对应的极坐标角度值，以弧度表示。 | double result = atan2(1.0, 1.0); |
| ceil | double ceil(double x) | 返回大于或等于参数的最小整数值。 | double result = ceil(3.14); |
| cos | double cos(double x) | 返回参数的余弦值，以弧度表示。 | double result = cos(0.5); |
| cosh | double cosh(double x) | 返回参数的双曲余弦值。 | double result = cosh(0.5); |
| exp | double exp(double x) | 返回自然对数的指数。 | double result = exp(1.0); |
| fabs | float fabs(float x) <br> double fabs(double x) <br> long double fabs(long double x) | 返回参数的绝对值。 | double result = fabs(-3.14); |
| floor | double floor(double x) | 返回小于或等于参数的最大整数值。 | double result = floor(3.14); |
| fmod | double fmod(double x, double y) | 返回参数与除数的浮点余数。 | double result = fmod(10.5, 3.2); |
| log | double log(double x) | 返回参数的自然对数。 | double result = log(2.71828); |
| log10 | double log10(double x) | 返回参数的以10为底的对数。 | double result = log10(100.0); |
| pow | double pow(double x, double y) | 返回x的y次幂。 | double result = pow(2.0, 3.0); |
| sqrt | double sqrt(double x) | 返回参数的平方根。 | double result = sqrt(16.0); |
| sin | double sin(double x) | 返回参数的正弦值，以弧度表示。 | double result = sin(0.5); |
| sinh | double sinh(double x) | 返回参数的双曲正弦值。 | double result = sinh(0.5); |
| tan | double tan(double x) | 返回参数的正切值，以弧度表示。 | double result = tan(0.5); |
| tanh | double tanh(double x) | 返回参数的双曲正切值。 | double result = tanh(0.5); |
| frexp | double frexp(double value, int* exp) <br> float frexp(float value, int* exp) <br> long double frexp(long double value, int* exp) | 将浮点数拆分为尾数和指数，并将指数存储在`exp`指针所指向的整型变量中。返回尾数值。 | double x = 123.45; int exponent; double mantissa = frexp(x, &exponent); |
| modf | double modf(double value, double* intpart) <br> float modf(float value, float* intpart) <br> long double modf(long double value, long double* intpart) | 将浮点数拆分为整数部分和小数部分，并将整数部分存储在`intpart`指针所指向的变量中。返回小数部分值。 | double x = 123.45; double intpart; double fracpart = modf(x, &intpart); |

这是C++ `cmath`头文件中的所有函数的详细信息。
#### algorithm
[开头](#c帮助文档)
以下是C++ `algorithm`头文件中的所有函数的详细信息（包括函数名、函数原型、描述和使用示例）：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| --- | --- | --- | --- |
| all_of | bool all_of(InputIt first, InputIt last, UnaryPredicate p) | 检查给定范围内的所有元素是否都满足谓词`p`，如果是则返回`true`，否则返回`false`。 | vector<int> nums = {1, 2, 3, 4, 5}; bool result = all_of(nums.begin(), nums.end(), [](int x) { return x > 0; }); |
| any_of | bool any_of(InputIt first, InputIt last, UnaryPredicate p) | 检查给定范围内的任意元素是否满足谓词`p`，如果有满足的元素则返回`true`，否则返回`false`。 | vector<int> nums = {1, 2, 3, 4, 5}; bool result = any_of(nums.begin(), nums.end(), [](int x) { return x % 2 == 0; }); |
| none_of | bool none_of(InputIt first, InputIt last, UnaryPredicate p) | 检查给定范围内的所有元素是否都不满足谓词`p`，如果是则返回`true`，否则返回`false`。 | vector<int> nums = {1, 2, 3, 4, 5}; bool result = none_of(nums.begin(), nums.end(), [](int x) { return x < 0; }); |
| for_each | Function for_each(InputIt first, InputIt last, UnaryFunction f) | 对给定范围内的每个元素执行函数`f`。 | vector<int> nums = {1, 2, 3, 4, 5}; for_each(nums.begin(), nums.end(), [](int x) { cout << x << " "; }); |
| find | InputIt find(InputIt first, InputIt last, const T& value) | 在给定范围内查找值为`value`的元素，返回指向找到的元素的迭代器，如果找不到则返回`last`。 | vector<int> nums = {1, 2, 3, 4, 5}; auto it = find(nums.begin(), nums.end(), 3); |
| find_if | InputIt find_if(InputIt first, InputIt last, UnaryPredicate p) | 在给定范围内查找满足谓词`p`的元素，返回指向找到的元素的迭代器，如果找不到则返回`last`。 | vector<int> nums = {1, 2, 3, 4, 5}; auto it = find_if(nums.begin(), nums.end(), [](int x) { return x > 3; }); |
| find_if_not | InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate p) | 在给定范围内查找不满足谓词`p`的元素，返回指向找到的元素的迭代器，如果找不到则返回`last`。 | vector<int> nums = {1, 2, 3, 4, 5}; auto it = find_if_not(nums.begin(), nums.end(), [](int x) { return x < 3; }); |
| count | DifferenceType count(InputIt first, InputIt last, const T& value) | 统计给定范围内值为`value`的元素个数。 | vector<int> nums = {1, 2, 2, 3, 2, 4, 5}; int result = count(nums.begin(), nums.end(), 2); |
| count_if | DifferenceType count_if(InputIt first, InputIt last, UnaryPredicate p) | 统计给定范围内满足谓词`p`的元素个数。 | vector<int> nums = {1, 2, 3, 4, 5}; int result = count_if(nums.begin(), nums.end(), [](int x) { return x % 2 == 0; }); |
| transform | OutputIt transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOperation op) | 对给定范围内的两个序列进行操作，并将结果存储在输出迭代器`d_first`指向的位置。 | vector<int> nums1 = {1, 2, 3, 4, 5}; vector<int> nums2 = {10, 20, 30, 40, 50}; vector<int> result(nums1.size()); transform(nums1.begin(), nums1.end(), nums2.begin(), result.begin(), [](int x, int y) { return x + y; }); |
| sort | void sort(RandomIt first, RandomIt last) | 对给定范围内的元素进行升序排序。 | vector<int> nums = {5, 3, 1, 4, 2}; sort(nums.begin(), nums.end()); |
| reverse | void reverse(BidirIt first, BidirIt last) | 反转给定范围内的元素顺序。 | vector<int> nums = {1, 2, 3, 4, 5}; reverse(nums.begin(), nums.end()); |
| unique | ForwardIt unique(ForwardIt first, ForwardIt last) | 移除给定范围内的重复元素，并返回指向新范围末尾的迭代器。 | vector<int> nums = {1, 2, 2, 3, 3, 4, 4, 5}; auto it = unique(nums.begin(), nums.end()); |
| binary_search | bool binary_search(ForwardIt first, ForwardIt last, const T& value) | 判断给定范围内是否存在值为`value`的元素，返回`true`表示找到，`false`表示未找到。范围必须是已排序的。 | vector<int> nums = {1, 2, 3, 4, 5}; bool result = binary_search(nums.begin(), nums.end(), 3); |
| merge | void merge(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2, OutputIt d_first) | 将已排序的两个范围合并到输出迭代器`d_first`指向的位置。 | vector<int> nums1 = {1, 3, 5}; vector<int> nums2 = {2, 4, 6}; vector<int> result(nums1.size() + nums2.size()); merge(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), result.begin()); |
| max_element | ForwardIt max_element(ForwardIt first, ForwardIt last) | 返回给定范围内的最大元素的迭代器。 | vector<int> nums = {1, 3, 2, 5, 4}; auto it = max_element(nums.begin(), nums.end()); |
| min_element | ForwardIt min_element(ForwardIt first, ForwardIt last) | 返回给定范围内的最小元素的迭代器。 | vector<int> nums = {1, 3, 2, 5, 4}; auto it = min_element(nums.begin(), nums.end()); |

这是C++ `algorithm`头文件中的所有函数的详细信息。

#### cstdlib
[开头](#c帮助文档)
以下是C++ `cstdlib` 头文件中的所有函数的详细信息（包括函数名、函数原型、描述和使用示例）：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| ---- | ---- | ---- | ---- |
| atoi | int atoi(const char* str) | 将字符串转换为整数。 | const char* str = "12345"; int num = atoi(str); |
| atof | double atof(const char* str) | 将字符串转换为浮点数。 | const char* str = "3.14"; double num = atof(str); |
| strtol | long int strtol(const char* str, char** endptr, int base) | 将字符串转换为长整型数。 | const char* str = "12345"; char* endptr; long int num = strtol(str, &endptr, 10); |
| strtoul | unsigned long int strtoul(const char* str, char** endptr, int base) | 将字符串转换为无符号长整型数。 | const char* str = "12345"; char* endptr; unsigned long num = strtoul(str, &endptr, 10); |
| srand | void srand(unsigned int seed) | 设置随机数生成器的种子。 | srand(time(NULL)); |
| rand | int rand() | 产生一个伪随机整数。 | int num = rand(); |
| calloc | void* calloc(size_t num, size_t size) | 分配并初始化一个大小为 `num * size` 的内存块。 | int* arr = (int*)calloc(5, sizeof(int)); |
| malloc | void* malloc(size_t size) | 分配一个大小为 `size` 的内存块。 | int* arr = (int*)malloc(5 * sizeof(int)); |
| realloc | void* realloc(void* ptr, size_t size) | 重新分配已分配内存块的大小。 | int* arr = (int*)malloc(5 * sizeof(int)); arr = (int*)realloc(arr, 10 * sizeof(int)); |
| free | void free(void* ptr) | 释放先前通过 `malloc`、`calloc` 或 `realloc` 分配的内存块。 | int* arr = (int*)malloc(5 * sizeof(int)); free(arr); |
| system | int system(const char* command) | 在操作系统上执行命令。 | const char* command = "ls -l"; int exit_code = system(command); |

这是C++ `cstdlib` 头文件中的所有函数的详细信息。

#### vector
[开头](#c帮助文档)
以下是C++ `vector` 头文件中的所有函数的详细信息（包括函数名、函数原型、描述和使用示例）：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| ---- | ---- | ---- | ---- |
| vector | vector\<T, Allocator\> | 默认构造函数，创建一个空的 `vector` 对象。 | vector\<int\> myVector; |
| vector | vector\<T, Allocator\>(size_type n) | 构造函数，创建一个具有 `n` 个默认构造的元素的 `vector` 对象。 | vector\<int\> myVector(5); |
| vector | vector\<T, Allocator\>(size_type n, const T& value) | 构造函数，创建一个具有 `n` 个值为 `value` 的元素的 `vector` 对象。 | vector\<int\> myVector(5, 10); |
| vector | vector\<T, Allocator\>(const vector& other) | 拷贝构造函数，创建一个与 `other` 一样的 `vector` 对象。 | vector\<int\> myVector(otherVector); |
| ~vector | ~vector() | 析构函数，销毁 `vector` 对象，并释放占用的内存。 | 在对象不再使用时自动调用。 |
| assign | void assign(InputIterator first, InputIterator last) | 将迭代器范围 `[first, last)` 内的元素赋值给 `vector` 对象。 | vector\<int\> myVector; myVector.assign(beginVec, endVec); |
| assign | void assign(size_type n, const T& value) | 将 `n` 个值为 `value` 的元素赋值给 `vector` 对象。 | vector\<int\> myVector; myVector.assign(5, 10); |
| at | reference at(size_type pos) | 返回位于位置 `pos` 的元素的引用，并进行边界检查。 | int value = myVector.at(2); |
| operator[] | reference operator[](size_type pos) | 重载操作符 `[]`，返回位于位置 `pos` 的元素的引用。 | int value = myVector[2]; |
| front | reference front() | 返回首个元素的引用。 | int value = myVector.front(); |
| back | reference back() | 返回最后一个元素的引用。 | int value = myVector.back(); |
| data | T* data() | 返回指向底层数组的指针。 | int* ptr = myVector.data(); |
| empty | bool empty() | 检查 `vector` 是否为空。 | if (myVector.empty()) { ... } |
| size | size_type size() | 返回 `vector` 中元素的个数。 | size_type count = myVector.size(); |
| max_size | size_type max_size() | 返回 `vector` 可以容纳的最大元素数。 | size_type maxSize = myVector.max_size(); |
| clear | void clear() | 清空 `vector` 中的所有元素。 | myVector.clear(); |
| insert | iterator insert(const_iterator pos, const T& value) | 在指定位置 `pos` 前插入值为 `value` 的元素，并返回指向插入的元素的迭代器。 | iterator it = myVector.insert(myVector.begin() + 3, 20); |
| erase | iterator erase(const_iterator pos) | 移除指定位置 `pos` 处的元素，并返回指向下一个位置的迭代器。 | iterator it = myVector.erase(myVector.begin() + 2); |
| push_back | void push_back(const T& value) | 在尾部添加一个值为 `value` 的元素。 | myVector.push_back(30); |
| pop_back | void pop_back() | 移除尾部的元素。 | myVector.pop_back(); |
| resize | void resize(size_type n) | 更改 `vector` 的大小，使其包含 `n` 个元素。如果新的大小大于当前大小，将默认构造新元素。 | myVector.resize(10); |
| swap | void swap(vector& other) | 交换两个 `vector` 对象的内容。 | myVector.swap(otherVector); |

这是C++ `vector` 头文件中的所有函数的详细信息。
#### ctime
[开头](#c帮助文档)
以下是C++ `ctime` 头文件中的所有函数的详细信息（包括函数名、函数原型、描述和使用示例）：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| ---- | ---- | ---- | ---- |
| time | time_t time(time_t* arg) | 获取当前的系统时间，并将其以自纪元时间秒数形式存储到 `arg` 所指的对象中（如果 `arg` 不为 `nullptr`）。 | time_t currentTime = time(nullptr); |
| localtime | tm* localtime(const time_t* timer) | 将自纪元时间秒数表示的时间转换为当地时间，并返回一个指向 `tm` 结构的指针，其中包含了当地的时间和日期信息。 | time_t currentTime = time(nullptr); tm* localTime = localtime(&currentTime); |
| gmtime | tm* gmtime(const time_t* timer) | 将自纪元时间秒数表示的时间转换为 UTC 时间（格林尼治标准时间），并返回一个指向 `tm` 结构的指针，其中包含了 UTC 的时间和日期信息。 | time_t currentTime = time(nullptr); tm* utcTime = gmtime(&currentTime); |
| mktime | time_t mktime(tm* timeptr) | 将一个包含时间和日期信息的 `tm` 结构转换为自纪元时间秒数的形式。 | tm localTime; localTime.tm_sec = 30; localTime.tm_min = 15; localTime.tm_hour = 9; time_t epochTime = mktime(&localTime); |
| strftime | size_t strftime(char* str, size_t count, const char* format, const tm* timeptr) | 根据格式字符串 `format`，将 `tm` 结构表示的时间转换为字符串，并将其存储在 `str` 所指的位置。 | char buffer[80]; time_t currentTime = time(nullptr); tm* localTime = localtime(&currentTime); strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", localTime); |
| asctime | char* asctime(const tm* timeptr) | 将 `tm` 结构表示的时间转换为字符串，并返回一个指向表示时间的静态字符数组的指针。 | time_t currentTime = time(nullptr); tm* localTime = localtime(&currentTime); char* timeString = asctime(localTime); |
| ctime | char* ctime(const time_t* timer) | 将自纪元时间秒数表示的时间转换为字符串，并返回一个指向表示时间的静态字符数组的指针。 | time_t currentTime = time(nullptr); char* timeString = ctime(&currentTime); |
| difftime | double difftime(time_t time1, time_t time2) | 计算从时间 `time1` 到时间 `time2` 的时间差（以秒为单位）。 | time_t startTime = time(nullptr); // Some operations time_t endTime = time(nullptr); double elapsedSeconds = difftime(endTime, startTime); |

这是C++ `ctime` 头文件中的所有函数的详细信息。
#### cstring
[开头](#c帮助文档)
以下是C++ `cstring` 头文件中的所有函数的详细信息（包括函数名、函数原型、描述和使用示例）：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| ---- | ---- | ---- | ---- |
| strlen | size_t strlen(const char* str) | 返回以空字符 `\0` 结尾的字符串 `str` 的长度，不包括空字符本身。 | const char* str = "Hello World"; size_t length = strlen(str); |
| strcat | char* strcat(char* dest, const char* src) | 将字符串 `src` 连接到字符串 `dest` 的末尾，并返回指向 `dest` 的指针。 | char dest[30] = "Hello"; const char* src = "World"; char* result = strcat(dest, src); |
| strcpy | char* strcpy(char* dest, const char* src) | 将字符串 `src` 复制到字符串 `dest`，包括空字符 `\0`，并返回指向 `dest` 的指针。 | char dest[30]; const char* src = "Hello"; char* result = strcpy(dest, src); |
| strncpy | char* strncpy(char* dest, const char* src, size_t count) | 将字符串 `src` 的最多 `count` 个字符复制到字符串 `dest`，如果 `src` 的长度小于 `count`，则用空字符 `\0` 填充剩余的字符，并返回指向 `dest` 的指针。 | char dest[30]; const char* src = "Hello"; char* result = strncpy(dest, src, 3); |
| strcmp | int strcmp(const char* str1, const char* str2) | 按字典顺序比较两个字符串 `str1` 和 `str2`。 | const char* str1 = "Hello"; const char* str2 = "World"; int result = strcmp(str1, str2); |
| strncmp | int strncmp(const char* str1, const char* str2, size_t count) | 按字典顺序比较两个字符串 `str1` 和 `str2` 的最多 `count` 个字符。 | const char* str1 = "Hello"; const char* str2 = "World"; int result = strncmp(str1, str2, 3); |
| strchr | char* strchr(const char* str, int character) | 在字符串 `str` 中查找字符 `character` 的第一次出现，返回指向该字符的指针，如果没有找到，则返回 `nullptr`。 | const char* str = "Hello World"; char* result = strchr(str, 'W'); |
| strrchr | char* strrchr(const char* str, int character) | 在字符串 `str` 中逆向查找字符 `character` 的最后一次出现，返回指向该字符的指针，如果没有找到，则返回 `nullptr`。 | const char* str = "Hello World"; char* result = strrchr(str, 'o'); |
| strstr | char* strstr(const char* str1, const char* str2) | 在字符串 `str1` 中查找字符串 `str2` 的第一次出现，返回指向该位置的指针，如果没有找到，则返回 `nullptr`。 | const char* str1 = "Hello World"; const char* str2 = "World"; char* result = strstr(str1, str2); |
| strtok | char* strtok(char* str, const char* delimiters) | 将字符串 `str` 分解为一系列标记（由 `delimiters` 包含的字符分隔），返回指向每个标记的指针。首次调用时，`str` 不为空，后续调用传递 `nullptr` 作为第一个参数。 | char str[] = "Hello,World"; const char* delimiters = ","; char* token = strtok(str, delimiters); |
| memcmp | int memcmp(const void* ptr1, const void* ptr2, size_t count) | 按字节比较 `ptr1` 和 `ptr2` 所指向的内存块的前 `count` 个字节。 | const char str1[] = "Hello"; const char str2[] = "World"; int result = memcmp(str1, str2, 3); |
| memcpy | void* memcpy(void* dest, const void* src, size_t count) | 将 `src` 所指向的内存块的前 `count` 个字节复制到 `dest` 所指向的内存块，并返回指向 `dest` 的指针。 | char dest[30]; const char* src = "Hello"; void* result = memcpy(dest, src, 5); |
| memmove | void* memmove(void* dest, const void* src, size_t count) | 将 `src` 所指向的内存块的前 `count` 个字节复制到 `dest` 所指向的内存块，即使两个内存块有重叠，也能正确工作。 | char str[30] = "Hello World"; void* result = memmove(str + 6, str, 5); |
| memset | void* memset(void* ptr, int value, size_t count) | 将内存块 `ptr` 的前 `count` 个字节设置为给定的 `value`。 | char str[30]; void* result = memset(str, 'A', 5); |

这是 C++ `cstring` 头文件中的所有函数的详细信息。
#### string
[开头](#c帮助文档)
C++ 标准库中的 `string` 类提供了一组丰富的成员函数，用于操作字符串。以下是 `string` 类的所有成员函数的详细信息：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| ---- | ---- | ---- | ---- |
| 构造函数 | string() | 创建一个空字符串对象 | string str; |
| | string(const string& str) | 创建一个字符串对象，并使用另一个字符串对象 `str` 进行初始化 | string str1 = "Hello"; string str2(str1); |
| | string(const char* s) | 创建一个字符串对象，并使用 C 风格字符串 `s` 进行初始化 | const char* s = "Hello"; string str(s); |
| | string(size_t count, char ch) | 创建一个由重复字符 `ch` 组成的字符串对象 | size_t count = 5; char ch = 'A'; string str(count, ch); |
| 成员函数 | size_t size() const | 返回字符串的长度（字符数） | string str = "Hello"; size_t length = str.size(); |
| | bool empty() const | 检查字符串是否为空 | string str = "Hello"; bool isEmpty = str.empty(); |
| | const char* c_str() const | 返回指向以空字符结尾的字符数组的指针 | string str = "Hello"; const char* cString = str.c_str(); |
| | string& operator=(const string& str) | 将字符串对象 `str` 赋值给当前对象 | string str1 = "Hello"; string str2; str2 = str1; |
| | string& operator=(const char* s) | 将 C 风格字符串 `s` 赋值给当前对象 | const char* s = "Hello"; string str; str = s; |
| | char& operator[](size_t pos) | 访问字符串中指定位置的字符 | string str = "Hello"; char& c = str[1]; |
| | char& at(size_t pos) | 访问字符串中指定位置的字符，并进行边界检查 | string str = "Hello"; char& c = str.at(1); |
| | string& operator+=(const string& str) | 在当前字符串末尾追加字符串 `str` | string str1 = "Hello"; string str2 = " World"; str1 += str2; |
| | string& operator+=(const char* s) | 在当前字符串末尾追加 C 风格字符串 `s` | string str = "Hello"; str += " World"; |
| | string& append(const string& str) | 在当前字符串末尾追加字符串 `str` | string str1 = "Hello"; string str2 = " World"; str1.append(str2); |
| | string& append(const char* s) | 在当前字符串末尾追加 C 风格字符串 `s` | string str = "Hello"; str.append(" World"); |
| | string& append(const char* s, size_t count) | 在当前字符串末尾追加 `count` 个字符 | string str = "Hello"; str.append(" World", 5); |
| | string& insert(size_t pos, const string& str) | 在指定位置插入字符串 `str` | string str1 = "Hello"; string str2 = " World"; str1.insert(5, str2); |
| | string& insert(size_t pos, const char* s) | 在指定位置插入 C 风格字符串 `s` | string str = "Hello"; str.insert(5, " World"); |
| | string& insert(size_t pos, const char* s, size_t count) | 在指定位置插入 `count` 个字符 | string str = "Hello"; str.insert(5, " World", 5); |
| | string& erase(size_t pos, size_t count) | 删除从指定位置开始的 `count` 个字符 | string str = "Hello World"; str.erase(6, 5); |
| | void clear() | 清空字符串内容，使其成为空字符串 | string str = "Hello"; str.clear(); |
| | int compare(const string& str) const | 比较两个字符串的大小，返回一个整数 | string str1 = "Hello"; string str2 = "World"; int result = str1.compare(str2); |
| | int compare(const char* s) const | 比较字符串与 C 风格字符串的大小，返回一个整数 | string str = "Hello"; const char* s = "World"; int result = str.compare(s); |
| | string substr(size_t pos, size_t count) const | 返回一个包含从位置 `pos` 开始的 `count` 个字符的子字符串 | string str = "Hello World"; string subStr = str.substr(6, 5); |
| | void swap(string& str) | 交换当前字符串与另一个字符串 `str` 的内容 | string str1 = "Hello"; string str2 = "World"; str1.swap(str2); |
| 静态函数 | static int compare(const string& str1, const string& str2) | 比较两个字符串的大小，返回一个整数 | string str1 = "Hello"; string str2 = "World"; int result = string::compare(str1, str2); |
| | static string to_string(int value) | 将整数转换为字符串 | int num = 123; string str = string::to_string(num); |
| | static int stoi(const string& str, size_t* pos = 0, int base = 10) | 将字符串转换为整数 | string str = "123"; int num = string::stoi(str); |
| | static long stol(const string& str, size_t* pos = 0, int base = 10) | 将字符串转换为长整数 | string str = "123"; long num = string::stol(str); |
| | static double stod(const string& str, size_t* pos = 0) | 将字符串转换为双精度浮点数 | string str = "3.14"; double num = string::stod(str); |

这是 C++ 标准库中 `string` 类的所有成员函数的详细信息。
#### cctype
[开头](#c帮助文档)
C++ 标准库中的 `<cctype>` 头文件提供了一组用于字符处理的函数和宏。以下是 `<cctype>` 头文件中的所有函数的详细信息：

| 函数名 | 函数原型 | 描述 | 使用示例 |
| ---- | ---- | ---- | ---- |
| isalnum | int isalnum(int c) | 检查字符 `c` 是否是字母或数字字符 | char ch = 'A'; int result = isalnum(ch); |
| isalpha | int isalpha(int c) | 检查字符 `c` 是否是字母字符 | char ch = 'A'; int result = isalpha(ch); |
| isblank | int isblank(int c) | 检查字符 `c` 是否是空白字符（空格或制表符） | char ch = ' '; int result = isblank(ch); |
| iscntrl | int iscntrl(int c) | 检查字符 `c` 是否是控制字符 | char ch = '\n'; int result = iscntrl(ch); |
| isdigit | int isdigit(int c) | 检查字符 `c` 是否是数字字符 | char ch = '9'; int result = isdigit(ch); |
| isgraph | int isgraph(int c) | 检查字符 `c` 是否是可打印字符（除空格之外的可见字符） | char ch = '!'; int result = isgraph(ch); |
| islower | int islower(int c) | 检查字符 `c` 是否是小写字母字符 | char ch = 'a'; int result = islower(ch); |
| isprint | int isprint(int c) | 检查字符 `c` 是否是可打印字符（包括空格） | char ch = ' '; int result = isprint(ch); |
| ispunct | int ispunct(int c) | 检查字符 `c` 是否是标点符号字符 | char ch = '.'; int result = ispunct(ch); |
| isspace | int isspace(int c) | 检查字符 `c` 是否是空白字符（包括空格、制表符、换行符等） | char ch = ' '; int result = isspace(ch); |
| isupper | int isupper(int c) | 检查字符 `c` 是否是大写字母字符 | char ch = 'A'; int result = isupper(ch); |
| isxdigit | int isxdigit(int c) | 检查字符 `c` 是否是十六进制数字字符 | char ch = 'F'; int result = isxdigit(ch); |
| tolower | int tolower(int c) | 将字符 `c` 转换为小写字母字符 | char ch = 'A'; int result = tolower(ch); |
| toupper | int toupper(int c) | 将字符 `c` 转换为大写字母字符 | char ch = 'a'; int result = toupper(ch); |

这是 C++ `<cctype>` 头文件中的所有函数的详细信息。

### 自定义函数
[开头](#c帮助文档)
在C++中，函数是一种可重复使用的代码段，用于完成特定的任务。函数提供了代码的模块化和组织化，可以使程序更容易理解、调试和维护。在C++中定义和调用函数很简单。

函数的定义包括函数名、返回类型、参数列表和函数体。函数的定义告诉编译器函数应该如何执行。

下面是一个简单的函数定义的示例：
```cpp
// 函数定义
返回类型 函数名(参数列表) {
    // 函数体
    // 执行特定任务的代码
}
```

函数定义中的各部分具体解释如下：
- `返回类型`：指定函数返回的数据类型，可以是基本类型（如`int`、`float`等）或自定义类型（如结构体）。
- `函数名`：给函数起个名称，用于在调用函数时引用该函数。
- `参数列表`：列出函数所接受的输入参数的类型和名称。每个参数由数据类型和参数名组成，多个参数之间用逗号分隔。
- `函数体`：这是函数的实际代码块，包含要执行的一系列语句。

示例：定义一个简单的函数，计算两个整数的和。
```cpp
#include <iostream>

int sum(int num1, int num2) {
    int result = num1 + num2;
    return result;
}

int main() {
    int a = 5;
    int b = 3;
    int total = sum(a, b); // 调用函数

    std::cout << "Sum: " << total << std::endl;

    return 0;
}
```

函数的调用使用函数名和相应的参数。返回值是函数执行后的结果，可以在函数调用点使用或存储在变量中。

需要注意的是，函数可以有返回值，也可以没有。如果函数没有返回值，返回类型应该声明为`void`。

示例：定义一个不返回值的函数，打印欢迎信息。
```cpp
#include <iostream>

void welcome() {
    std::cout << "Welcome to my program!" << std::endl;
}

int main() {
    welcome(); // 调用函数

    return 0;
}
```

函数还可以有默认参数。默认参数是在定义函数时为参数提供的初始值，调用函数时可以省略这些参数。

示例：定义带有默认参数的函数，计算矩形的面积。
```cpp
#include <iostream>

int calculateArea(int length = 5, int width = 3) {
    return length * width;
}

int main() {
    int area1 = calculateArea(); // 不提供参数，默认使用默认值 5 和 3
    int area2 = calculateArea(8); // 提供一个参数，使用默认值 3
    int area3 = calculateArea(4, 6); // 提供两个参数

    std::cout << "Area 1: " << area1 << std::endl;
    std::cout << "Area 2: " << area2 << std::endl;
    std::cout << "Area 3: " << area3 << std::endl;

    return 0;
}
```

在C++中，函数的声明和定义可以分开。函数的声明告诉编译器函数的名称、返回类型和参数列表，函数的定义包含完整的函数代码。

示例：将函数的声明和定义分离。
```cpp
#include <iostream>

// 函数声明
int sum(int num1, int num2);

int main() {
    int a = 5;
    int b = 3;
    int total = sum(a, b); // 调用函数

    std::cout << "Sum: " << total << std::endl;

    return 0;
}

// 函数定义
int sum(int num1, int num2) {
    int result = num1 + num2;
    return result;
}
```

通过函数，可以将复杂的任务分解为较小的部分，使代码更易于编写和维护。函数在C++中是非常基础和重要的概念，可以提高代码的效率和可读性。

### 内联函数
[开头](#c帮助文档)
C++中的内联函数是一种特殊类型的函数，它通过在编译时进行代码插入而不是函数调用，以提高函数调用的效率。内联函数通常用于简单且频繁调用的函数，以减少函数调用的开销。

要定义内联函数，需要在函数定义前加上`inline`关键字。

示例：
```cpp
inline int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 5); // 内联函数调用
    return 0;
}
```

内联函数的特点：
- 每次调用内联函数时，不会发生函数调用的开销，而是直接将函数体插入到调用点。
- 内联函数一般比普通函数更小，因为它的函数体被复制到每个调用点，而不是在程序中的每个调用点重复生成一次函数的副本。
- 内联函数的定义通常放在头文件中，以便在其他源文件中进行调用。

需要注意以下几点：
- 内联函数适用于短小的、执行时间很短的函数。如果函数体过长，内联函数可能会降低性能，因为插入函数体会导致代码膨胀。
- 编译器可以选择是否真正将函数定义为内联函数。使用`inline`关键字只是对编译器提供了一种建议，编译器会根据情况决定是否内联函数。
- 内联函数的定义应放在头文件中，并在需要使用该函数的源文件中包含头文件。

使用内联函数可以提高函数调用的效率，但应谨慎使用。在编写代码时，可以根据函数的复杂程度和使用情况来决定是否使用内联函数。

### 函数重载
[开头](#c帮助文档)
C++函数重载是指在同一作用域内定义多个名称相同但参数列表不同的函数。通过函数重载，可以使用相同的函数名执行不同的操作，以适应不同的数据类型和参数组合。

函数重载的规则：
- 函数名称必须相同。
- 参数列表必须不同。参数列表可以包括参数的数量、类型或顺序的差异。
- 返回类型可以相同也可以不同，但不能以返回类型来区分函数重载。

示例：
```cpp
#include <iostream>

// 重载的函数
void print(int number) {
    std::cout << "Integer: " << number << std::endl;
}

void print(double number) {
    std::cout << "Double: " << number << std::endl;
}

void print(std::string str) {
    std::cout << "String: " << str << std::endl;
}

int main() {
    print(10); // 调用第一个重载函数
    print(3.14); // 调用第二个重载函数
    print("Hello"); // 调用第三个重载函数

    return 0;
}
```

在上面的示例中，有三个名为`print`的函数被重载。它们分别接受不同的参数类型，并根据传递的参数类型执行相应的操作。

需要注意以下几点：
- C++编译器根据传递的参数类型和数量来确定要调用的函数。它会根据最佳匹配规则选择合适的函数进行调用。
- 重载函数的返回类型不是识别重载的标准，因此不能通过返回类型来区分函数重载。
- 除了参数列表不同之外，函数的其他方面（比如函数体和函数名称）可以相同或不同。

通过函数重载，可以以一种清晰和一致的方式编写函数，且代码更易读、维护和重用。函数重载使得函数能够适应不同的数据类型和使用场景，提高了函数的灵活性和通用性。

### 模板函数
[开头](#c帮助文档)
C++模板函数是一种通用的函数，可以用于处理不同类型的数据，即泛型编程。使用模板函数可以编写一次代码，用于多种数据类型，提高了代码的重用性和灵活性。

模板函数通过在函数定义中使用模板参数来实现泛型。模板参数可以是类型参数或非类型参数。

示例：
```cpp
#include <iostream>

// 模板函数
template <typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    int maxInt = maximum(3, 5); // 调用模板函数，类型推断为int
    double maxDouble = maximum(3.14, 2.71); // 调用模板函数，类型推断为double
    char maxChar = maximum('a', 'b'); // 调用模板函数，类型推断为char

    std::cout << "Max int: " << maxInt << std::endl;
    std::cout << "Max double: " << maxDouble << std::endl;
    std::cout << "Max char: " << maxChar << std::endl;

    return 0;
}
```

在上面的示例中，`maximum`是一个模板函数，使用`typename T`定义了类型参数`T`。在调用模板函数时，编译器会根据传递的参数类型推断出适当的参数类型并进行实例化。

除了类型参数，还可以使用非类型参数来定义模板函数。非类型参数在模板参数列表中声明，并可以作为常量或枚举类型的值传递给函数。

示例：
```cpp
#include <iostream>

// 模板函数
template <typename T, int size>
void printArray(T (&arr)[size]) {
    for (int i = 0; i < size; i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

int main() {
    int intArray[] = {1, 2, 3, 4, 5};
    double doubleArray[] = {1.1, 2.2, 3.3, 4.4, 5.5};

    printArray(intArray); // 调用模板函数，类型推断为int[]
    printArray(doubleArray); // 调用模板函数，类型推断为double[]

    return 0;
}
```

在上面的示例中，`printArray`是一个模板函数，使用了类型参数`T`和非类型参数`size`。参数`T (&arr)[size]`表示一个引用数组（大小为`size`）的参数。

使用模板函数可以在不限制于特定数据类型的情况下编写通用的、可重用的代码。模板函数在STL（标准模板库）中广泛使用，如容器（vector、list）、算法（sort、find）等。模板函数使得C++具有了强大的泛型编程能力。

## 预处理命令
[开头](#c帮助文档)
在C++中，预处理命令是在编译之前由预处理器执行的指令，用于对源代码进行预处理。预处理命令以 `#` 开头，并且在编译器处理源代码之前被解析和展开。以下是一些常用的C++预处理命令：

1. `#include`：
   `#include` 用于引入其他文件的内容。可以使用 `#include` 将头文件（以 `.h` 或 `.hpp` 结尾）或其他源代码文件包含到当前源文件中。例如：
   ```cpp
   #include <iostream> // 引入iostream标准库头文件
   #include "myheader.h" // 引入自定义头文件
   ```

2. `#define`：
   `#define` 用于定义宏。可以使用 `#define` 定义一个标识符，该标识符在源代码中被替换为相应的替代文本。例如：
   ```cpp
   #define PI 3.14159
   #define MAX(a, b) ((a) > (b) ? (a) : (b))
   
   double radius = 5.0;
   double circumference = 2 * PI * radius;
   
   int largerNumber = MAX(10, 5);
   ```

3. `#ifdef` 和 `#ifndef`：
   `#ifdef` 和 `#ifndef` 用于条件编译。`#ifdef` 用于检查一个标识符是否已定义，如果已定义，则编译下面的代码块，否则跳过。`#ifndef` 则是检查一个标识符是否未定义。例如：
   ```cpp
   #ifdef DEBUG
       // 仅在DEBUG宏定义时编译此段代码
       std::cout << "Debugging mode" << std::endl;
   #else
       // DEBUG宏未定义时编译此段代码
       std::cout << "Release mode" << std::endl;
   #endif
   ```

4. `#ifdef` 和 `#endif`：
   `#ifdef` 和 `#endif` 配合使用，用于定义条件编译的代码块。例如：
   ```cpp
   #ifdef FEATURE_A
       // FEATURE_A 宏定义时执行代码块
       // ...
   #elif defined(FEATURE_B)
       // FEATURE_A 未定义，但 FEATURE_B 宏定义时执行代码块
       // ...
   #else
       // FEATURE_A 和 FEATURE_B 都未定义时执行代码块
       // ...
   #endif
   ```

5. `#undef`：
   `#undef` 用于取消已定义的宏。可以使用 `#undef` 取消之前使用 `#define` 定义的宏。例如：
   ```cpp
   #define PI 3.14159
   
   #undef PI
   
   // 这里 PI 宏已被取消定义
   ```

预处理命令可以用于在编译之前进行源代码的处理和条件编译，使程序具有更高的灵活性。

## 源文件与头文件
[开头](#c帮助文档)
在C++中，通常将程序的源代码分为源文件（source file）和头文件（header file）两种类型。

源文件（source file）是包含实际代码的文件，通常以`.cpp`为文件扩展名。源文件包含了程序的实现细节，包括函数的具体实现、全局变量的定义和其他的具体实现代码。每个源文件通常对应一个编译单元，编译单元是编译器将源代码转换为目标代码的最小单元。

头文件（header file）是包含函数声明、类定义、常量定义和其他类型的声明的文件，通常以`.h`为文件扩展名。头文件主要用于在多个源文件之间共享代码，将声明和定义放在头文件中，然后在源文件中包含头文件即可使用其中的声明。头文件可以包含函数原型、类定义、常量声明等，但不包含具体实现代码。

C++的头文件可以包含以下内容：

1. 函数声明：头文件经常包含函数的声明，这样其他源文件就可以在需要时引用这些函数而无需知道其具体实现细节。函数声明中包括函数名称、参数列表和返回类型。

2. 类声明和定义：头文件中可以包含类的声明和定义。类的声明包括类名称、成员函数和成员变量的声明等信息，而类的定义则包括成员函数和成员变量的具体实现代码。

3. 常量和枚举：头文件中可以定义常量和枚举类型，以便在多个源文件中共享使用。常量可以用来定义程序中的固定值，而枚举类型可以用于定义一系列相关的常量值。

4. 类型定义和别名：头文件可以定义新的类型和类型别名，以提高代码的可读性和易用性。通过定义类型和别名，可以在代码中使用更具意义的名称，增加代码的可读性和可维护性。

5. 外部变量的声明：如果需要在多个源文件中共享相同的全局变量，可以将其声明放在头文件中，然后在多个源文件中包含该头文件以共享变量的声明。

6. 内联函数：内联函数的实现通常放在头文件中。内联函数是一种编译器优化的机制，它可以避免函数调用的开销，并直接将函数的代码插入到调用处，提高程序的执行效率。
   
7. 模板函数定义，因为模板函数定义只是描述了函数怎么生成


头文件的作用：
1. 提供接口：头文件定义了函数原型和类声明等接口，供其他源文件调用和使用。通过包含头文件，源文件可以访问并使用头文件中定义的接口。

2. 代码共享：头文件的主要目的是在多个源文件之间共享代码。通过将声明放在头文件中，可以在多个源文件中包含同一个头文件来共享声明。

3. 模块化和可维护性：将声明和定义分开可以提高代码的模块化和可维护性。头文件包含了接口定义，而源文件包含了具体实现，这样可以将代码分成逻辑上的模块，方便维护和修改。

示例：
[1.cpp]
```cpp
#include "myheader.h" // 包含头文件

int main() {
    int result = add(2, 3); // 调用头文件中定义的函数
    return 0;
}
```

[myheader.h]
```cpp
#ifndef MYHEADER_H // 头文件保护宏，防止重复包含
#define MYHEADER_H

int add(int a, int b); // 函数声明

#endif
```

[myheader.cpp]
```cpp
#include "myheader.h" // 包含头文件

int add(int a, int b) { // 函数定义
    return a + b;
}
```

在上面的示例中，`1.cpp`是源文件，包含了主函数，通过包含`myheader.h`头文件来使用其中定义的函数。在`myheader.h`头文件中进行了函数声明，并通过头文件保护宏防止重复包含。而函数的具体实现定义在`myheader.cpp`源文件中，通过包含`myheader.h`头文件来使用其中声明的函数。

总结来说，源文件包含实现代码，头文件包含声明和接口定义。通过使用头文件，可以提高代码的可读性、模块化性和可维护性，以及方便代码共享和重用。

## 命名空间
[开头](#c帮助文档)
C++中的命名空间（Namespace）是一种用于组织和管理代码的机制，它可以将相关的函数、类、变量等内容放在同一个逻辑分组中，以避免命名冲突并提高代码的可读性和可维护性。

命名空间的语法如下：
```cpp
namespace namespace_name {
    // 声明和定义
}
```

在命名空间中，可以包含各种声明和定义，包括函数、类、变量、枚举、其他命名空间等。

可以通过以下方式使用命名空间中的内容：
- 在命名空间中定义的函数或变量：使用`namespace_name::function_name`或`namespace_name::variable_name`来访问。
- 在命名空间中定义的类：使用`namespace_name::class_name`来访问。
- 在命名空间中定义的命名空间：可以嵌套使用，例如`namespace_name1::namespace_name2::function_name`。

以下是一个简单的示例：

```cpp
namespace MyNamespace {
    int add(int a, int b) {
        return a + b;
    }
}

int main() {
    int result = MyNamespace::add(2, 3);
    return 0;
}
```

在上述示例中，`add`函数被定义在名为`MyNamespace`的命名空间中。在主函数中，通过`MyNamespace::add()`来调用该函数。

命名空间的使用可以避免不同代码之间的命名冲突，特别是在多人合作或将第三方代码集成到项目中时。它也提供了一种逻辑上划分代码的方式，使得代码的组织和管理更加清晰和可维护。同时，命名空间也可以通过`using`指令引入，从而简化对命名空间中的内容的访问。例如，可以使用`using MyNamespace::add`来直接使用`add`函数，而无需使用完整的命名空间限定符。

## 引用变量
[开头](#c帮助文档)
在C++中，引用是一个已存在的对象的别名，它提供了一种简洁且安全地访问对象的方式。引用变量在声明时需要使用`&`符号来指示。

引用有以下特点：
- 引用必须在声明时进行初始化，并且不能再引用其他对象。
- 引用一旦与某个对象绑定，就可以看作是该对象的别名，对引用的操作实际上就是对原对象的操作。
- 引用不占用额外的内存，它只是作为原对象的别名存在，对引用的访问和修改都直接作用于原对象。

以下是引用的基本使用示例：

```cpp
int main() {
    int num = 10;  // 声明一个整型变量
    int& ref = num;  // 声明一个整型引用，并与num绑定

    cout << num << endl;  // 输出：10
    cout << ref << endl;  // 输出：10

    ref = 20;  // 修改引用的值，等价于修改num的值

    cout << num << endl;  // 输出：20
    cout << ref << endl;  // 输出：20

    return 0;
}
```

在上述示例中，`ref`是一个整型引用，与`num`绑定，因此对`ref`的修改实际上是对`num`的修改。通过引用，可以直接对原对象进行操作，而无需使用指针或复制对象。

引用常用于以下场景：
- 以引用方式传递函数参数：可以通过引用来传递函数的参数，以便在函数内部修改调用者传递的变量。
- 避免对象的拷贝开销：通过引用作为函数或方法的返回值，可以直接操作原对象，避免了拷贝的开销。

需要注意的是，对于引用的使用需要谨慎，确保引用绑定的对象在引用的生命周期内一直有效。引用一旦绑定之后，无法再修改绑定的对象，它相当于对象的一个常量别名。

## 类与对象
[开头](#c帮助文档)
### 类的实现与使用
在C++中，类是一种用户自定义的数据类型，它用于封装数据和方法（成员函数）以实现特定的功能。类提供了一种面向对象的编程方式，可以将相关的数据和操作组织在一起，以提高代码的可读性、可维护性和重用性。

类的定义通常包括以下几个部分：

1. 类声明（Class Declaration）：在类声明中，指定类的名称和访问修饰符，还可以声明类的成员变量和成员函数。类的声明通常写在头文件中（.h或.hpp文件）。

   ```cpp
   class MyClass {
   public:
       // 声明成员函数和成员变量
   };
   ```

2. 类实现（Class Implementation）：在类的实现中，实现类声明中的成员函数，以及定义类声明中的成员变量。类的实现通常写在源文件中（.cpp文件）。

   ```cpp
   // MyClass.h

   class MyClass {
   public:
       void myFunction();  // 声明成员函数

   private:
       int myVariable;  // 声明私有成员变量
   };

   // MyClass.cpp

   #include "MyClass.h"

   void MyClass::myFunction() {
       // 实现成员函数
   }
   ```

3. 对象的创建和使用：通过类来创建对象，使用对象来调用类中的成员函数和访问成员变量。

   ```cpp
   int main() {
       MyClass obj;  // 创建MyClass类的对象
       obj.myFunction();  // 调用对象的成员函数
       return 0;
   }
   ```

在类的设计中，可以使用访问修饰符（`public`、`private`、`protected`）来指定成员的可访问性。成员变量和成员函数可以被限定为公有（`public`）、私有（`private`）或受保护（`protected`）。

公有成员可以被类外部和派生类访问，私有成员只能在类内部访问，受保护成员类似于私有成员，但可以被派生类访问。

类的设计还可以包括构造函数、析构函数、静态成员、友元函数等特性，以满足不同的需求和实现更复杂的逻辑。

通过使用类，可以将相关的数据和操作封装在一起，实现数据的封装和抽象，提供更高层次的代码组织和封装，从而提高代码的可维护性和重用性。

### 对象数组
[开头](#c帮助文档)
在C++中，可以创建对象数组来存储多个对象，这样可以方便地管理和操作一组相关的对象。

对象数组的创建方式与一般数组类似，通过指定对象的类型和大小来声明和定义一个对象数组。以下是创建对象数组的基本步骤：

1. 声明对象数组：在合适的位置声明对象数组，指定对象类型和数组大小。

   ```cpp
   class MyClass {
       // 类的定义
   };

   int main() {
       MyClass arrayName[SIZE];  // 声明对象数组
       // ...
       return 0;
   }
   ```

2. 访问对象数组：可以通过下标操作符`[]`访问对象数组中的每个元素，然后进行操作。

   ```cpp
   arrayName[index].memberFunction();  // 调用对象数组中元素的成员函数
   ```

下面是一个完整的示例，展示了如何声明和使用对象数组：

```cpp
#include <iostream>
using namespace std;

class Point {
private:
    int x, y;

public:
    void setPoint(int newX, int newY) {
        x = newX;
        y = newY;
    }

    void printPoint() {
        cout << "Point: (" << x << ", " << y << ")" << endl;
    }
};

int main() {
    const int SIZE = 5;
    Point pointsArray[SIZE];  // 声明大小为SIZE的Point对象数组

    // 设置对象数组中每个元素的坐标值
    for (int i = 0; i < SIZE; i++) {
        pointsArray[i].setPoint(i, i+1);
    }

    // 打印对象数组中每个元素的坐标值
    for (int i = 0; i < SIZE; i++) {
        pointsArray[i].printPoint();
    }

    return 0;
}
```

在上述示例中，我们声明了大小为`SIZE`的`Point`对象数组`pointsArray`，然后使用循环依次设置每个元素的坐标值。最后，再使用循环打印每个元素的坐标值。

通过使用对象数组，我们可以高效地管理和处理一组相关的对象，以及对它们进行统一的操作。需要注意的是，在使用对象数组时，需要根据需要合理地管理对象的生命周期，避免悬空指针或内存泄漏的问题。

### 构造函数与析构函数
[开头](#c帮助文档)
构造函数和析构函数是C++类中的两个特殊成员函数，它们在对象的创建和销毁过程中起着重要的作用。

1. 构造函数（Constructor）：
   - 构造函数是一种特殊的成员函数，它在创建对象时自动调用，用于初始化对象的数据成员。
   - 构造函数的名称必须与类名相同，没有返回类型（连void都没有）。
   - 构造函数可以有多个重载版本，可以根据参数的类型和数量的不同进行重载。
   - 如果没有显式定义构造函数，编译器会提供一个默认构造函数，用于执行默认的对象初始化。
   - 构造函数可以用于在创建对象时执行各种初始化操作，如分配内存、初始化数据成员、打开文件等。

   示例：
   ```cpp
   class MyClass {
   public:
       // 默认构造函数
       MyClass() {
           // 初始化数据成员
       }

       // 带参数的构造函数
       MyClass(int value) {
           // 使用参数初始化数据成员
       }
   };

   int main() {
       MyClass obj1;        // 使用默认构造函数创建对象
       MyClass obj2(10);    // 使用带参数的构造函数创建对象
       return 0;
   }
   ```

2. 析构函数（Destructor）：
   - 析构函数也是一种特殊的成员函数，它在对象销毁时自动调用，用于执行清理对象的操作。
   - 析构函数的名称也必须与类名相同，在前面加上一个波浪号`~`。
   - 析构函数没有参数和返回值。
   - 如果没有显式定义析构函数，编译器会提供一个默认的析构函数，用于执行默认的对象清理操作。
   - 析构函数可以用于释放分配的资源、关闭文件、删除动态分配的内存等。

   示例：
   ```cpp
   class MyClass {
   public:
       // 析构函数
       ~MyClass() {
           // 执行清理操作
       }
   };

   int main() {
       MyClass obj;    // 创建对象
       // 对象使用...
       return 0;       // 对象超出作用域，析构函数被自动调用
   }
   ```

通过合理使用构造函数和析构函数，可以确保对象的正确初始化和清理，避免资源泄漏和不稳定的状态。构造函数负责对象的初始化，构造对象时自动调用；析构函数负责对象的清理，对象销毁时自动调用。这些特点使得构造函数和析构函数在面向对象编程中非常重要。

### this指针
[开头](#c帮助文档)
在C++中，每个非静态成员函数都有一个隐含的指向当前对象的指针，称为`this`指针。`this`指针指向调用该成员函数的对象，可以在成员函数内部使用`this`指针来访问当前对象的成员变量和成员函数。

下面是关于`this`指针的一些基本知识：

1. `this`指针的特点：
   - `this`指针是一个常量指针，它的值不能被修改。即`this`指针不能被重新赋值。
   - `this`指针的类型是指向当前类的非常量版本的指针。对于常量成员函数，`this`指针的类型是指向常量的指针（`const`指针）。
   - 在成员函数内部，可以使用`this`指针来访问当前对象的成员变量和成员函数。

2. 使用`this`指针的示例：
   ```cpp
   class MyClass {
   private:
       int value;

   public:
       void setValue(int value) {
           this->value = value;  // 使用this指针访问成员变量
       }

       void printValue() const {
           cout << "Value: " << value << endl;  // 使用this指针访问成员变量
       }
   };

   int main() {
       MyClass obj;
       obj.setValue(10);
       obj.printValue();  // 输出：Value: 10
       return 0;
   }
   ```

在上面的示例中，成员函数`setValue`使用`this`指针来访问成员变量`value`，以区分形参`value`和成员变量`value`。成员函数`printValue`使用`const`关键字修饰，表示它是一个常量成员函数，此时`this`指针的类型是指向常量的指针。

`this`指针在C++中具有重要的作用，它提供了一种在成员函数内部引用当前对象的方法，并允许在对象之间进行区分。使用`this`指针可以确保对当前对象成员的正确访问，尤其在成员变量与形参同名的情况下更为重要。

### 类继承
[开头](#c帮助文档)
在C++中，类继承是一种重要的面向对象编程概念，它允许创建一个新类（称为派生类或子类），该类继承了另一个已有类（称为基类、父类或超类）的属性和行为。子类可以使用基类的成员，同时还可以根据需要添加新的成员和重新定义或扩展继承的成员。

下面是关于C++类继承的一些基本知识：

1. 基本语法：
   - 在派生类的类声明中使用`class 派生类名 : 访问控制 基类名`的语法表示继承关系。其中，访问控制关键字可以是`public`、`protected`或`private`，用于定义派生类对基类成员的访问权限。
   - 默认情况下，派生类继承基类的成员时使用`private`访问控制，这意味着基类的公有和保护成员在派生类中的访问权限将变为私有。使用`protected`或`public`访问控制关键字可以改变这种默认行为。

2. 继承类型：
   - 公有继承（public inheritance）：派生类可以访问基类的公有和保护成员，继承的成员在派生类中的访问权限保持不变。
   - 保护继承（protected inheritance）：派生类可以访问基类的保护成员，继承的成员在派生类中的访问权限变为保护。
   - 私有继承（private inheritance）：派生类不能直接访问基类的成员，继承的成员在派生类中的访问权限变为私有。

3. 在派生类中访问和重定义成员：
   - 派生类可以使用基类的成员，包括公有和保护成员。在派生类中，可以直接访问基类的公有成员，而对于保护成员，可以通过派生类的成员函数来间接访问。
   - 派生类可以对继承的成员进行重新定义，即重写（override）或隐藏（hide）。使用`override`关键字可以显式表示重写基类的虚函数。
   - 如果派生类中定义了与基类同名的成员函数，基类的该成员函数将被隐藏，并且在派生类对象上无法直接调用基类的该成员函数。

4. 虚函数和多态性：
   - 在继承中，基类可以声明虚函数，允许派生类重写这些函数。通过虚函数，可以实现多态性，使得在运行时根据对象的实际类型来调用适当的函数。
   - 虚函数使用`virtual`关键字进行声明，并通过在基类中定义虚函数，派生类可以通过重写这些虚函数来覆盖基类的实现。

下面是一个简单的示例，演示了类的继承和基类、派生类之间的关系：

```cpp
class Shape {
public:
    void print() {
        cout << "This is a shape." << endl;
    }
};

class Rectangle : public Shape {
public:
    void print() {
        cout << "This is a rectangle." << endl;
    }
};

int main() {
    Shape shape;
    shape.print();      // 输出：This is a shape.

    Rectangle rectangle;
    rectangle.print();  // 输出：This is a rectangle.
    
    // 派生类对象也可以赋值给基类引用或指针
    Shape& shapeRef = rectangle;
    shapeRef.print();   // 输出：This is a rectangle.

    return 0;
}
```

在上面的示例中，`Rectangle`类继承自`Shape`类。派生类`Rectangle`可以访问基类`Shape`的公有成员函数`print()`，并且可以重定义（重新实现）`print()`函数以改变其行为。通过将派生类对象赋值给基类引用或指针，可以实现多态性，根据对象的实际类型调用适当的函数。

类继承是C++中重要的面向对象编程概念之一。它能够通过继承基类的属性和行为来实现代码的复用和拓展，同时提供多态性和代码组织的灵活性。在实际编程中，要合理设计继承关系，遵循面向对象的设计原则，以保证代码的可维护性和清晰性。

### 运算符重载
[开头](#c帮助文档)
C++允许用户根据自己的需求来重载运算符，即通过定义运算符的行为来扩展内置的运算符。这是C++语言的强大特性之一。运算符重载使得自定义类型的对象可以像内置类型一样使用运算符，更方便、直观地操作对象。

下面我将介绍一些运算符重载的基本知识和示例：

1. 运算符重载的基本规则：
   - 运算符重载是通过定义全局函数或成员函数来实现的。
   - 运算符重载函数的命名格式为`operator 运算符`，例如`operator+`表示重载加法运算符。
   - 运算符重载函数可以作为成员函数或非成员函数进行定义，但不可同时定义成两者。
   - 如果定义为成员函数，其左侧的操作数为调用对象，右侧的操作数通过参数传递。如果定义为非成员函数，则需要使用参数列表标识两个操作数。
   - 运算符重载函数可以定义为友元函数，以便访问私有成员。
   - 运算符重载函数可以返回对象或其他类型的值。

2. 运算符重载示例：
   - 重载加法运算符`+`：
     ```cpp
     class Complex {
     private:
         double real;
         double imag;

     public:
         Complex(double r, double i) : real(r), imag(i) {}

         Complex operator+(const Complex& other) {
             Complex result(real + other.real, imag + other.imag);
             return result;
         }
     };

     int main() {
         Complex a(1.0, 2.0);
         Complex b(3.0, 4.0);
         Complex c = a + b;   // 调用重载的加法运算符
         return 0;
     }
     ```

   - 重载索引运算符`[]`：
     ```cpp
     class Array {
     private:
         int data[5];

     public:
         int& operator[](int index) {
             return data[index];
         }
     };

     int main() {
         Array arr;
         arr[0] = 1;     // 修改数组元素的值
         int value = arr[0];   // 获取数组元素的值
         return 0;
     }
     ```

   - 重载输入输出流运算符`>>`和`<<`：
     ```cpp
     class Point {
     private:
         int x;
         int y;

     public:
         friend ostream& operator<<(ostream& os, const Point& point) {
             os << "Point(" << point.x << ", " << point.y << ")";
             return os;
         }

         friend istream& operator>>(istream& is, Point& point) {
             is >> point.x >> point.y;
             return is;
         }
     };

     int main() {
         Point p;
         cout << "Enter x and y coordinates: ";
         cin >> p;     // 从输入流中获取坐标值
         cout << "Point: " << p << endl;   // 输出点的坐标
         return 0;
     }
     ```

通过运算符重载，可以让自定义类型的对象使用类似于内置类型的方式进行操作和交互，使代码更加简洁、易读和直观。要注意在运算符重载时遵循适当的语义和语法规则，确保运算符的行为符合预期和常理。

### 模板类
[开头](#c帮助文档)
在C++中，模板类是一种通用的类，可以用于创建具有相同结构但可以适用于不同数据类型的类。模板类允许在定义类时指定一个或多个类型参数，这些参数可以用于在类定义中声明变量、函数和操作符等。

下面是一个简单的示例，展示了一个C++模板类的定义和使用：

```cpp
template<typename T>
class MyTemplateClass {
public:
    MyTemplateClass(T value) : data(value) {}

    void printData() {
        std::cout << "Data: " << data << std::endl;
    }

private:
    T data;
};

int main() {
    MyTemplateClass<int> myIntObject(10);
    MyTemplateClass<std::string> myStringObject("Hello");

    myIntObject.printData(); // 输出: Data: 10
    myStringObject.printData(); // 输出: Data: Hello

    return 0;
}
```

在上述示例中，`MyTemplateClass`是一个模板类，它以一个 `typename T` 作为类型参数。在类定义内部，我们使用 `T` 来声明了一个私有数据成员 `data`，并在构造函数中对它进行初始化。

在`main()`函数中，我们创建了两个`MyTemplateClass`的实例，分别使用了不同的数据类型 `int` 和 `std::string` 作为实例化的类型参数。通过调用 `printData()` 函数，我们打印出了不同实例的数据。

需要注意的是，模板类的定义和实现通常放在头文件中，以便在需要使用模板类的源文件中包含和实例化模板类时，编译器可以看到完整的类定义和实现。

C++中的模板类提供了一种强大和灵活的机制，可以实现代码的复用和通用性。模板类广泛应用于容器类（如`std::vector`）、算法（如`std::sort`）等标准库组件中。

## 动态内存分配
[开头](#c帮助文档)
在C++中，动态内存分配允许在程序运行时动态地分配和释放内存，这种内存分配是通过使用`new`和`delete`操作符来实现的。

1. 动态内存分配的基本用法：
   - 使用`new`操作符来动态地分配内存，返回一个指向分配内存的指针，并可以进行类型转换。
   - 使用`delete`操作符来释放先前通过`new`分配的内存，并防止内存泄漏。

示例代码：
```cpp
int* ptr = new int;  // 动态分配int类型的内存空间
*ptr = 10;          // 在分配的内存中存储值
delete ptr;         // 释放内存空间
```

2. 动态数组的分配和释放：
   - 使用`new`操作符创建动态数组，使用方括号指定数组大小，返回指向数组的指针。
   - 使用`delete[]`操作符释放先前通过`new`分配的动态数组。

示例代码：
```cpp
int size = 5;
int* arr = new int[size];   // 动态分配int类型的数组
for (int i = 0; i < size; i++) {
    arr[i] = i;             // 在数组中存储值
}
delete[] arr;               // 释放动态数组的内存空间
```

需要注意几点：
- 动态分配的内存需要手动释放，防止内存泄漏。使用完毕后，务必使用`delete`或`delete[]`释放内存。
- 使用`delete`操作符释放单个对象的内存，使用`delete[]`操作符释放动态数组的内存。
- 注意动态数组的大小，防止越界访问。
- 在进行动态内存分配时，如果无法成功分配所需的内存，会抛出`std::bad_alloc`异常，需要适当处理异常。

动态内存分配在某些情况下非常有用，特别是在需要在运行时确定对象数量或需要动态变化数组大小的情况下。然而，使用动态内存分配时应格外小心，以避免内存泄漏和悬空指针等问题。另外，C++11引入了智能指针（如`std::shared_ptr`和`std::unique_ptr`），可以更安全和方便地管理动态分配的内存。

## 友元与异常
[开头](#c帮助文档)
友元（Friend）和异常处理（Exception Handling）是C++中的两个重要概念。下面我将进一步介绍它们的特性和使用方法。

1. 友元（Friend）：
   - 友元是一种特殊的访问权限，允许一个函数或类访问另一个类的私有成员。
   - 友元关系可以在类内部或类外部声明，可以是函数、类或整个类的所有成员。
   - 友元关系通过在类的声明中使用`friend`关键字进行指定。
   - 友元关系打破了类的封装性，因此应谨慎使用，仅在必要时使用。

   示例：
   ```cpp
   class MyClass {
   private:
       int privateData;

   public:
       friend void friendFunc(MyClass& obj);  // friendFunc是MyClass的友元函数

       void accessPrivateData() {
           cout << "Private data: " << privateData << endl;
       }
   };

   void friendFunc(MyClass& obj) {
       obj.privateData = 10;   // 友元函数可以访问MyClass的私有成员
   }

   int main() {
       MyClass obj;
       friendFunc(obj);  // 通过友元函数修改私有成员
       obj.accessPrivateData();  // 通过成员函数访问私有成员
       return 0;
   }
   ```

2. 异常处理（Exception Handling）：
   - 异常处理是一种机制，用于处理程序运行中可能发生的异常情况。
   - 异常通过使用`throw`语句在代码中抛出，并通过`try-catch`块来捕获和处理。
   - `try`块用于标识可能引发异常的代码块。
   - `throw`语句用于抛出异常对象。
   - `catch`块用于捕获和处理异常，根据异常类型选择相应的处理逻辑。

   示例：
   ```cpp
   void divide(int a, int b) {
       if (b == 0) {
           throw "Divide by zero exception";  // 抛出异常
       }
       int result = a / b;
       cout << "Result: " << result << endl;
   }

   int main() {
       try {
           divide(10, 0);  // 可能会抛出异常
       }
       catch (const char* msg) {
           cerr << "Exception caught: " << msg << endl;  // 捕获并处理异常
       }
       return 0;
   }
   ```

友元和异常处理是C++中非常有用的功能，它们能够提供更大的灵活性和控制能力。然而，在使用友元时需谨慎保护封装性，使用异常处理时需考虑异常的类型和处理方式，以保证程序的正确性和可靠性。

## 编写与调用dll文件
[开头](#c帮助文档)
以下是关于C++中的DLL文件的详细解释、编写DLL文件示例，使用Visual Studio 2022环境：
**DLL文件**：
DLL（Dynamic Link Library）文件是一种在Windows操作系统中常用的动态链接库文件。它包含一组功能函数和数据，可以被多个程序共享和调用，并且能够在运行时被动态加载和链接到程序中。通过使用DLL文件，可以实现代码的模块化和重用，减小程序的体积。

**编写DLL文件示例**：
以下是使用Visual Studio 2022编写DLL文件的示例，包括求和、排序、显示"Hello, World!"的函数以及一个数学函数类，注释，导出类与函数。

1. 创建一个新的C++项目（选择“空项目”）。
2. 在解决方案资源管理器中，右键单击项目并选择“添加” -> “新建项”。
3. 在弹出的对话框中选择“代码” -> “C++头文件”。
4. 命名文件为`fun.h`，然后在文件中编写以下代码：

```cpp
#ifdef FUN_EXPORTS
#define DLL_API __declspec(dllexport)
#else
#define DLL_API __declspec(dllimport)
#endif

// 这是一个数学函数类
class DLL_API MathFunctions
{
public:
    // 求和函数
    // 参数: a和b为相加的两个整数
    // 返回值: 返回a和b的和
    int Sum(int a, int b);

    // 排序函数
    // 参数: array为待排序的数组, size为数组大小
    // 无返回值
    void Sort(int* array, int size);
};

// 显示"Hello, World!"的函数
// 无参数和返回值
DLL_API void HelloWorld();
```

5. 在解决方案资源管理器中，右键单击项目并选择“添加” -> “新建项”。
6. 在弹出的对话框中选择“代码” -> “C++文件”。
7. 命名文件为`fun.cpp`，然后在文件中编写以下代码：

```cpp
#include "fun.h"
#include <iostream>

int MathFunctions::Sum(int a, int b)
{
    return a + b;
}

void MathFunctions::Sort(int* array, int size)
{
    // 这里写排序逻辑，例如使用快速排序算法
}

void HelloWorld()
{
    std::cout << "Hello, World!" << std::endl;
}
```

在上述示例中，我们使用`__declspec(dllexport)`和`__declspec(dllimport)`来指定函数和类的导入和导出属性，以便在DLL文件和其他程序之间正确地进行函数和类的动态链接。同时，我们在注释中添加了关于函数和类的说明，以便他人理解和使用。

**调用DLL文件函数示例**：
以下是一个使用Visual Studio 2022调用DLL文件中函数的示例，

1. 创建一个新的C++项目（选择“控制台应用程序”）。
2. 在解决方案资源管理器中，右键单击项目并选择“添加” -> “现有项”。
3. 将创建的.dll文件以及.lib文件还有定义的.h头文件,拷贝至我们需要测试的新项目的目录下。
4. 将拷贝的头文件`fun.h`添加到空白项目中
5. 在属性—链接器—输入—附加依赖项中添加我们拷贝过来的.lib文件
6. 在解决方案资源管理器中，右键单击项目并选择“添加” -> “现有项”。
7. 选择`fun.h`文件，然后点击“添加”。
8. 在解决方案资源管理器中的`main.cpp
9. 在`main.cpp`文件中编写以下代码：

```cpp
#include "fun.h"

int main()
{
    MathFunctions math;

    int sum = math.Sum(2, 3);
    math.Sort(nullptr, 0);
    HelloWorld();

    return 0;
}
```

在上述示例中，我们通过包含`fun.h`头文件，在`main.cpp`文件中直接调用了DLL文件中的函数。我们创建了一个`MathFunctions`对象，并调用了其`Sum`函数进行求和，调用了`Sort`函数进行排序，以及调用了`HelloWorld`函数打印"Hello, World!"。

请注意，为了使用DLL文件中的函数，需要将DLL文件添加到项目中并包含相应的头文件。在`main`函数内，我们创建了一个`MathFunctions`对象，因此我们可以直接调用该对象的成员函数。函数调用和使用与常规的C++函数调用相同。

